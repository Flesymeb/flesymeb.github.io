[{"content":" ","date":"2025-05-21","externalUrl":null,"permalink":"/","section":".","summary":"\u003c!-- \u003cdiv class=\"flex px-4 py-2 mb-8 text-base rounded-md bg-primary-100 dark:bg-primary-900\"\u003e\n  \u003cspan class=\"flex items-center ltr:pr-3 rtl:pl-3 text-primary-400\"\u003e\n    \n    \n      \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n        \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n    \n      \u003c/span\u003e\n    \n\n  \u003c/span\u003e\n  \u003cspan class=\"flex items-center justify-between grow dark:text-neutral-300\"\u003e\n    \u003cspan class=\"prose dark:prose-invert\"\u003e 这是 \u003ccode id=\"layout\"\u003ebackground\u003c/code\u003e 的样式示例。\u003c/span\u003e\n    \u003cbutton\n      id=\"switch-layout-button\"\n      class=\"px-4 !text-neutral !no-underline rounded-md bg-primary-600 hover:!bg-primary-500 dark:bg-primary-800 dark:hover:!bg-primary-700\"\n    \u003e\n      切换 layout \u0026orarr;\n    \u003c/button\u003e\n  \u003c/span\u003e\n\u003c/div\u003e --\u003e\n\u003c!-- ```node\nnpx blowfish-tools\n``` --\u003e\n\u003c!-- \u003clite-youtube videoid=\"SgXhGb-7QbU\" playlabel=\"SgXhGb-7QbU\" params=\"\"\u003e\u003c/lite-youtube\u003e\n --\u003e","title":".","type":"page"},{"content":"总结一些常用的算法思路和模板\n搜索 # 1. 二分查找 # int binary_search(vector\u0026lt;int\u0026gt;\u0026amp; nums,int target) { int left = 0; int right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + (right - left) / 2; if(nums[mid] \u0026gt; target){ right = mid - 1; }else if(nums[mid] \u0026lt; target){ left = mid + 1; }else{ return mid; } } return -1; }; 2. 双指针 # // 时间复杂度：O(n) // 空间复杂度：O(1) class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex \u0026lt; nums.size(); fastIndex++) { if (val != nums[fastIndex]) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } }; 排序 # 1. 排序-选择排序 # void selectionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i = 0; i \u0026lt; n-1; i++){ int k = i; for(int j = i+1; j \u0026lt; n; j++){ if(nums[j] \u0026lt; nums[k]){ k = j; } } swap(nums[i],nums[k]); } } 2. 排序-冒泡排序 # void bubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i = n-1; i\u0026gt;0; i--){ for(int j = 0; j \u0026lt; i; j++){ if(nums[j] \u0026gt; nums[j+1]){ swap(nums[j],nums[j+1]); } } } } 使用Flag标记优化\nvoid bubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i = n-1; i\u0026gt;0; i--){ bool flag = false; for(int j = 0; j \u0026lt; i; j++){ if(nums[j] \u0026gt; nums[j+1]){ swap(nums[j],nums[j+1]); flag = true; } } if(!flag) break; } } 3. 排序-插入排序 # void insertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for(int i = 1; i \u0026lt; n; i++){ int base = nums[i]; int j = i - 1; while(j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; base){ nums[j+1] = nums[j]; j--; } nums[j+1] = base; //将base插入到合适的位置 } } 3. 排序-快速排序 # 哨兵划分\nint partition(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums[i], nums[j]); // 交换这两个元素 } swap(nums[i], nums[left]); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } 快速排序\nvoid quick_sort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { if(left \u0026gt;= right) return; int pivot = partition(nums, left, right); quick_sort(nums, left, pivot - 1); // 排序左子数组 quick_sort(nums, pivot + 1, right); // 排序右子数组 } 4. 排序-归并排序 # /* 合并左子数组和右子数组 */ void merge(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int mid, int right) { // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right] // 创建一个临时数组 tmp ，用于存放合并后的结果 vector\u0026lt;int\u0026gt; tmp(right - left + 1); // 初始化左子数组和右子数组的起始索引 int i = left, j = mid + 1, k = 0; // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中 while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (nums[i] \u0026lt;= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } // 将左子数组和右子数组的剩余元素复制到临时数组中 while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= right) { tmp[k++] = nums[j++]; } // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间 for (k = 0; k \u0026lt; tmp.size(); k++) { nums[left + k] = tmp[k]; } } /* 归并排序 */ void mergeSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 终止条件 if (left \u0026gt;= right) return; // 当子数组长度为 1 时终止递归 // 划分阶段 int mid = left + (right - left) / 2; // 计算中点 mergeSort(nums, left, mid); // 递归左子数组 mergeSort(nums, mid + 1, right); // 递归右子数组 // 合并阶段 merge(nums, left, mid, right); } 5. 排序-堆排序 # /* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */ void siftDown(vector\u0026lt;int\u0026gt; \u0026amp;nums, int n, int i) { while (true) { // 判断节点 i, l, r 中值最大的节点，记为 ma int l = 2 * i + 1; int r = 2 * i + 2; int ma = i; if (l \u0026lt; n \u0026amp;\u0026amp; nums[l] \u0026gt; nums[ma]) ma = l; if (r \u0026lt; n \u0026amp;\u0026amp; nums[r] \u0026gt; nums[ma]) ma = r; // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出 if (ma == i) { break; } // 交换两节点 swap(nums[i], nums[ma]); // 循环向下堆化 i = ma; } } /* 堆排序 */ void heapSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 建堆操作：堆化除叶节点以外的其他所有节点 for (int i = nums.size() / 2 - 1; i \u0026gt;= 0; --i) { siftDown(nums, nums.size(), i); } // 从堆中提取最大元素，循环 n-1 轮 for (int i = nums.size() - 1; i \u0026gt; 0; --i) { // 交换根节点与最右叶节点（交换首元素与尾元素） swap(nums[0], nums[i]); // 以根节点为起点，从顶至底进行堆化 siftDown(nums, i, 0); } } 分治 # 分治算法（Divide and Conquer）是一种将一个复杂问题分解为多个相似的子问题来解决的算法设计范式。它通常包括三个步骤：分解、解决和合并。分治算法的核心思想是将问题划分为更小的子问题，递归地解决这些子问题，然后将它们的结果合并起来得到原问题的解。\n1. 分治-分治算法模版 # // 分治函数模板 ReturnType divideAndConquer(const vector\u0026lt;int\u0026gt;\u0026amp; input, int left, int right) { // 1. 递归终止条件 if (left == right) { // 对于只包含一个元素的情况，直接返回结果 return input[left]; // 举例：最大值/最小值/计数等 } // 2. 分成左右两部分 int mid = left + (right - left) / 2; // 3. 递归解决子问题 ReturnType leftResult = divideAndConquer(input, left, mid); ReturnType rightResult = divideAndConquer(input, mid + 1, right); // 4. 合并左右结果 ReturnType result = merge(leftResult, rightResult); return result; } // 合并函数示意（可根据题目自定义逻辑） ReturnType merge(ReturnType left, ReturnType right) { // 举例：求最大值 return max(left, right); } 2. 分治-构建树 # class TreeNode { public: int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; /* 构建二叉树：分治 */ TreeNode *dfs(vector\u0026lt;int\u0026gt; \u0026amp;preorder, unordered_map\u0026lt;int, int\u0026gt; \u0026amp;inorderMap, int i, int l, int r) { // 子树区间为空时终止 if (r - l \u0026lt; 0) return NULL; // 初始化根节点 TreeNode *root = new TreeNode(preorder[i]); // 查询 m ，从而划分左右子树 int m = inorderMap[preorder[i]]; // 子问题：构建左子树 root-\u0026gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1); // 子问题：构建右子树 root-\u0026gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r); // 返回根节点 return root; } /* 构建二叉树 */ TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { // 初始化哈希表，存储 inorder 元素到索引的映射 unordered_map\u0026lt;int, int\u0026gt; inorderMap; for (int i = 0; i \u0026lt; inorder.size(); i++) { inorderMap[inorder[i]] = i; } TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorder.size() - 1); return root; } 回溯 # 回溯算法（Backtracking）是一种通过尝试所有可能的解来解决问题的算法。它通常用于组合、排列、子集等问题。回溯算法的核心思想是：在每一步选择中，尝试所有可能的选择，并在选择后进行递归搜索；如果发现当前选择不满足条件，则撤销该选择，回到上一步进行其他选择。 尝试与回退\n1. 回溯算法模版 # /* 回溯算法框架 */ void backtrack(State *state, vector\u0026lt;Choice *\u0026gt; \u0026amp;choices, vector\u0026lt;State *\u0026gt; \u0026amp;res) { // 判断是否为解 if (isSolution(state)) { // 记录解 recordSolution(state, res); // 不再继续搜索 return; } // 遍历所有选择 for (Choice choice : choices) { // 剪枝：判断选择是否合法 if (isValid(state, choice)) { // 尝试：做出选择，更新状态 makeChoice(state, choice); backtrack(state, choices, res); // 回退：撤销选择，恢复到之前的状态 undoChoice(state, choice); } } } 2. 回溯-全排列问题 # /* 全排列问题 */ void backtrack(vector\u0026lt;int\u0026gt; \u0026amp;state,const vector\u0026lt;int\u0026gt; \u0026amp;choices, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { // 当达到长度时，判断是否为解，并记录 if (state.size() == choices.size()) { res.push_back(state); return; } // 遍历所有选择 for (int i = 0; i \u0026lt; choices.size(); i++) { int choice = choices[i]; // 剪枝：判断选择是否合法 if(!selected[i]){ // 尝试：做出选择，更新状态 state.push_back(choice); selected[i] = true; // 递归调用，进行下一层的搜索 backtrack(state, choices, res); // 回退：撤销选择，恢复到之前的状态 state.pop_back(); selected[i] = false; } } } /* 全排列问题 */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 存储结果 vector\u0026lt;int\u0026gt; state; // 当前状态 vector\u0026lt;bool\u0026gt; selected(nums.size(), false); // 记录选择 backtrack(state, nums, res); // 调用回溯函数 return res; } 3. 子集和问题 # /* 回溯算法：子集和 I */ void backtrack(vector\u0026lt;int\u0026gt; \u0026amp;state, int target, int total, vector\u0026lt;int\u0026gt; \u0026amp;choices, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { // 子集和等于 target 时，记录解 if (total == target) { res.push_back(state); return; } // 遍历所有选择 for (size_t i = 0; i \u0026lt; choices.size(); i++) { // 剪枝：若子集和超过 target ，则跳过该选择 if (total + choices[i] \u0026gt; target) { continue; } // 尝试：做出选择，更新元素和 total state.push_back(choices[i]); // 进行下一轮选择 backtrack(state, target, total + choices[i], choices, res); // 回退：撤销选择，恢复到之前的状态 state.pop_back(); } } /* 求解子集和 I（包含重复子集） */ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsetSumINaive(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { vector\u0026lt;int\u0026gt; state; // 状态（子集） int total = 0; // 子集和 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 结果列表（子集列表） backtrack(state, target, total, nums, res); return res; } 动态规划 # 动态规划（dynamic programming，DP）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。 记忆化搜索时一种 “从顶至底” 的方法，而动态规划则是一种 “从底至顶” 的方法。\n1. 动态规划模版 # 第一步：思考每轮的决策，定义状态，从而得到 dp表 第二步：找出最优子结构，进而推导出状态转移方程 第三步：确定边界条件和状态转移顺序 2. 动态规划-走楼梯 # int climbingStairsDP(int n) { if(n == 1 || n == 2) return n; // 初始化dp表，用于存储子问题的解 vector\u0026lt;int\u0026gt; dp(n + 1, 0); dp[1] = 1; // 走到第1级台阶的方法数 dp[2] = 2; // 走到第2级台阶的方法数 //状态转移 for(int i=3; i\u0026lt;=n; ++i){ dp[i] = dp[i-1] + dp[i-2]; // 走到第i级台阶的方法数 } } 如果添加约束，不可以连续跳两个 1 阶\nint climbingStairsDP(int n) { if(n == 1 || n == 2) return n; // 初始化dp表，用于存储子问题的解 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(3,0)); dp[1][1] = 1; dp[1][2] = 0; dp[2][1] = 0; dp[2][2] = 1; //状态转移 for(int i=3; i\u0026lt;=n; ++i){ dp[i][1] = dp[i - 1][2]; dp[i][2] = dp[i - 2][1] + dp[i - 2][2]; } return dp[n][1] + dp[n][2]; } 3. 动态规划-01 背包问题 # int knapsackDP(vector\u0026lt;int\u0026gt; \u0026amp;wgt，vector\u0026lt;int\u0026gt; \u0026amp;val,int cap) { int n = wgt.size(); // 初始化dp表，用于存储子问题的解 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(cap + 1, 0)); // 状态转移 for(int i=1; i\u0026lt;=n; ++i){ for(int c=1; c\u0026lt;=cap; ++c){ if(c \u0026lt; wgt[i - 1]){ dp[i][c] = dp[i - 1][c]; // 不放入第i个物品 }else{ dp[i][c] = max(dp[i - 1][c],dp[i - 1][c - wgt[i - 1]] + val[i - 1]); // 放入第i个物品 } } } return dp[n][cap]; // 返回最大价值 } 4. 动态规划-零钱兑换 # /* 零钱兑换：动态规划 */ int coinChangeDP(vector\u0026lt;int\u0026gt; \u0026amp;coins, int amt) { int n = coins.size(); int MAX = amt + 1; // 初始化 dp 表 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(amt + 1, 0)); // 状态转移：首行首列 for (int a = 1; a \u0026lt;= amt; a++) { dp[0][a] = MAX; } // 状态转移：其余行和列 for (int i = 1; i \u0026lt;= n; i++) { for (int a = 1; a \u0026lt;= amt; a++) { if (coins[i - 1] \u0026gt; a) { // 若超过目标金额，则不选硬币 i dp[i][a] = dp[i - 1][a]; } else { // 不选和选硬币 i 这两种方案的较小值 dp[i][a] = min(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1); } } } return dp[n][amt] != MAX ? dp[n][amt] : -1; } 贪心 # 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用。 贪心选择性质与最优子结构\n贪心选择性质：局部最优解可以推出全局最优解。 最优子结构：一个问题的最优解包含其子问题的最优解。 1. 贪心算法模版 # // 通用贪心模板（以排序 + 贪心为核心） int greedyTemplate(vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026amp; items) { // 1. 按照某个策略对数据排序 sort(items.begin(), items.end(), [](const pair\u0026lt;int, int\u0026gt;\u0026amp; a, const pair\u0026lt;int, int\u0026gt;\u0026amp; b) { // 这里定义贪心策略，比如按权重/性价比/结束时间等排序 return a.second \u0026lt; b.second; // 示例：按第二个元素升序排序 }); // 2. 遍历并应用贪心策略 int result = 0; for (auto\u0026amp; item : items) { if (/* 当前item满足条件 */) { // 做出选择 result += item.first; // 示例：累加价值 } } return result; } 2. 贪心-分数背包 # /* 物品 */ class Item { public: int w; // 物品重量 int v; // 物品价值 Item(int w, int v) : w(w), v(v) { } }; /* 分数背包：贪心 */ double fractionalKnapsack(vector\u0026lt;int\u0026gt; \u0026amp;wgt, vector\u0026lt;int\u0026gt; \u0026amp;val, int cap) { // 创建物品列表，包含两个属性：重量、价值 vector\u0026lt;Item\u0026gt; items; for (int i = 0; i \u0026lt; wgt.size(); i++) { items.push_back(Item(wgt[i], val[i])); } // 按照单位价值 item.v / item.w 从高到低进行排序 sort(items.begin(), items.end(), [](Item \u0026amp;a, Item \u0026amp;b) { return (double)a.v / a.w \u0026gt; (double)b.v / b.w; }); // 循环贪心选择 double res = 0; for (auto \u0026amp;item : items) { if (item.w \u0026lt;= cap) { // 若剩余容量充足，则将当前物品整个装进背包 res += item.v; cap -= item.w; } else { // 若剩余容量不足，则将当前物品的一部分装进背包 res += (double)item.v / item.w * cap; // 已无剩余容量，因此跳出循环 break; } } return res; } 3. 贪心-Dijkstra 算法 # /* Dijkstra 算法 */ #include\u0026lt;bits/stdc++.h\u0026gt; #define INF 1000 #define MAX_V 100 using namespace std; int main() { int V,E; int i,j,m,n; int cost[MAX_V][MAX_V]; int d[MAX_V]; bool used[MAX_V]; cin\u0026gt;\u0026gt;V\u0026gt;\u0026gt;E; fill(d,d+V+1,INF); fill(used,used+V,false); for(i=0;i\u0026lt;V;i++) { for(j=0;j\u0026lt;V;j++) { if(i==j) cost[i][j]=0; else cost[i][j]=INF; } } for(m=0;m\u0026lt;E;m++) { cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;cost[i][j]; cost[j][i]=cost[i][j]; } cin\u0026gt;\u0026gt;n; d[n]=0; //源点 while(true) { int v=V; for(m=0;m\u0026lt;V;m++) { if((!used[m])\u0026amp;\u0026amp;(d[m]\u0026lt;d[v])) v=m; } if(v==V) break; used[v]=true; for(m=0;m\u0026lt;V;m++) { d[m]=min(d[m],d[v]+cost[v][m]); } } for(i=0;i\u0026lt;V;i++) { cout\u0026lt;\u0026lt;\u0026#34;the shortest distance between \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; and \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; is \u0026#34;\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;endl; } } ","date":"2025-05-21","externalUrl":null,"permalink":"/docs/algorithm/template/","section":"文档","summary":"\u003cp\u003e总结一些常用的算法思路和模板\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e搜索 \n    \u003cdiv id=\"%E6%90%9C%E7%B4%A2\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%90%9C%E7%B4%A2\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\n\u003ch3 class=\"relative group\"\u003e1. 二分查找 \n    \u003cdiv id=\"1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ebinary_search\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e  \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eright\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eleft\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eright\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etarget\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eleft\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 class=\"relative group\"\u003e2. 双指针 \n    \u003cdiv id=\"2-%E5%8F%8C%E6%8C%87%E9%92%88\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#2-%E5%8F%8C%E6%8C%87%E9%92%88\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"c1\"\u003e// 时间复杂度：O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 空间复杂度：O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eSolution\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003epublic\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eremoveElement\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eslowIndex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003efastIndex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003efastIndex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"n\"\u003efastIndex\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003efastIndex\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eslowIndex\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003efastIndex\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eslowIndex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2 class=\"relative group\"\u003e排序 \n    \u003cdiv id=\"%E6%8E%92%E5%BA%8F\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%8E%92%E5%BA%8F\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\n\u003ch3 class=\"relative group\"\u003e1. 排序-选择排序 \n    \u003cdiv id=\"1-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#1-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eselectionSort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e]){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 class=\"relative group\"\u003e2. 排序-冒泡排序 \n    \u003cdiv id=\"2-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#2-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003ebubbleSort\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evector\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eswap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e\u003cspan class=\"n\"\u003enums\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用\u003ccode\u003eFlag\u003c/code\u003e标记优化\u003c/p\u003e","title":"【算法】常用算法模版总结","type":"docs"},{"content":"","date":"2025-05-21","externalUrl":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++","type":"tags"},{"content":"","date":"2025-05-21","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-05-21","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":" 学习 · 记录 · 分享 ","date":"2025-05-21","externalUrl":null,"permalink":"/docs/","section":"文档","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  学习 · 记录 · 分享\n\u003c/div\u003e\n\n\u003chr\u003e","title":"文档","type":"docs"},{"content":"","date":"2025-05-21","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"学习","type":"tags"},{"content":" Algorithm 头文件 # C++的算法头文件中有很多实用的函数\n排序 # sort()：对容器中的元素进行排序。依次传入三个参数，要排序区间的起点，要排序区间的终点+1，比较函数。比较函数可以不填，则默认为从小到大排序。 也可以使用greater\u0026lt;type\u0026gt;()来实现从大到小排序，或者自定义比较函数。\n#include\u0026lt;bits/\u0026gt;stdc++.h\u0026gt; using namespace std; int a[105]; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } sort(a,a+n); for(int i=0;i\u0026lt;n;i++){ printf(\u0026#34;%d \u0026#34;,a[i]); } return 0; } 查找 # lower_bound()：查找第一个大于等于 x 的数的位置。传入三个参数，要查找区间的起点，要查找区间的终点+1，x。返回值为指向第一个大于等于 x的数的迭代器。 upper_bound()：查找第一个大于 x 的数的位置。传入三个参数，要查找区间的起点，要查找区间的终点+1，x。返回值为指向第一个大于 x的数的迭代器。\n在从小到大的排序数组中： 两者都是利用二分查找实现的，时间复杂度为 O(logn)。从begin位置开始查找，直到end-1位置结束，不存在返回end。\n在从大到小的排序数组中：\nlower_bound(begin,end,num,greater\u0026lt;type\u0026gt;()) upper_bound(begin,end,num,greater\u0026lt;type\u0026gt;())\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int cmp(int a,int b){ return a\u0026gt;b; } int main(){ int num[6]={1,2,4,7,15,34}; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout\u0026lt;\u0026lt;pos1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num[pos1]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;pos2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num[pos2]\u0026lt;\u0026lt;endl; sort(num,num+6,cmp); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater\u0026lt;int\u0026gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater\u0026lt;int\u0026gt;())-num; //返回数组中第一个小于被查数的值 cout\u0026lt;\u0026lt;pos3\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num[pos3]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;pos4\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num[pos4]\u0026lt;\u0026lt;endl; return 0; } 优先队列 # priority_queue：优先队列，默认是大根堆。可以使用greater\u0026lt;type\u0026gt;()来实现小根堆。\n操作类别 方法/函数 说明 插入元素 push(val) 插入元素并维护堆序 删除元素 pop() 删除堆顶（最大或最小） 访问元素 top() 访问当前优先级最高的元素 其他功能 empty() / size() 容器状态 遍历方式 ❌ 不支持遍历（非线性结构） 默认特性 最大堆 使用 \u0026lt; 比较，最大值优先 自定义优先级 使用 greater\u0026lt;type\u0026gt; 构造最 #include\u0026lt;bits/stdc++.h\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int main(){ priority_queue\u0026lt;int\u0026gt; q; //优先队列 q.push(1); q.push(2); q.push(3); while(!q.empty()){ cout\u0026lt;\u0026lt;q.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出队列中最大的数 q.pop(); //删除队列中最大的数 } return 0; } STL 模版使用 # C++的 STL（标准模板库）是一个强大的工具，提供了许多数据结构和算法的实现。STL 的使用可以大大简化代码，提高开发效率。\nvector # 通过vector\u0026lt;int\u0026gt; v可以实现一个储存整数的空的动态数组，支持随机访问。\n操作类别 方法/函数 说明 插入元素 push_back(val) 在末尾插入元素 insert(pos, val) 在指定位置插入元素 删除元素 pop_back() 删除末尾元素 erase(pos) 删除指定位置的元素 clear() 清空容器 查找元素 find(vec.begin(), vec.end(), val) 线性查找元素 访问元素 vec[i] / at(i) 访问第 i 个元素 其他功能 size() / empty() 获取大小 / 判断是否为空 随机访问支持 ✅ 常数时间访问 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; //创建一个空的动态数组} for(int i=0;i\u0026lt;10;i++){ v.push_back(i); //向数组中添加元素 } for(int i=0;i\u0026lt;v.size();i++){ cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出数组中的元素 } return 0; } list # 通过 list\u0026lt;int\u0026gt; L 来定义一个空的 list。当然 list 可以存任何类型的数据，比如 list\u0026lt;string\u0026gt; L 等等。 list 是一个双向链表，支持在任意位置插入和删除元素，适合频繁的插入和删除操作。\n操作类别 方法/函数 说明 插入元素 push_back(val) / push_front(val) 在末尾或开头插入元素 insert(pos, val) 在指定位置插入元素 删除元素 pop_back() / pop_front() 删除末尾或开头元素 erase(pos) 删除指定位置的元素 remove(val) 删除所有值为 val 的元素 查找元素 find(list.begin(), list.end(), val) 线性查找元素 访问元素 只能通过迭代器访问 不支持下标 其他功能 size() / empty() 获取大小 / 判断是否为空 随机访问支持 ❌ 不支持下标访问 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() { list\u0026lt;int\u0026gt; L; // 定义一个空的 list for (int i = 0; i \u0026lt; 10; i++) { L.push_back(i); // 向 list 中添加元素 } for (list\u0026lt;int\u0026gt;::iterator it = L.begin(); it != L.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 list 中的元素 } cout \u0026lt;\u0026lt; endl; return 0; } queue # 通过 queue\u0026lt;int\u0026gt; q 来定义一个储存整数的空的 queue。当然 queue 可以存任何类型的数据，比如 queue\u0026lt;string\u0026gt; q 等等。\n操作类别 方法/函数 说明 插入元素 push(val) 入队（尾部插入） 删除元素 pop() 出队（移除队首） 访问元素 front() / back() 获取队首 / 队尾元素 其他功能 empty() / size() 判断是否为空 / 获取大小 遍历方式 ❌ 不支持直接遍历 顺序特性 先进先出（FIFO） 队列结构特性 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int main() { queue\u0026lt;int\u0026gt; q;//定义一个队列 q.push(1);//入队 q.push(2); q.push(3); while (!q.empty()) {//当队列不为空 cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; endl;//取出队首元素 q.pop();//出队 } return 0; } stack # 通过 stack\u0026lt;int\u0026gt; S 来定义一个全局栈来储存整数的空的 stack。当然 stack 可以存任何类型的数据，比如 stack\u0026lt;string\u0026gt; S 等等。\n操作类别 方法/函数 说明 插入元素 push(val) 入栈（压栈） 删除元素 pop() 出栈（仅移除顶部元素） 访问元素 top() 查看栈顶元素 其他功能 empty() / size() 判断是否为空 / 获取元素个数 遍历方式 ❌ 不支持直接遍历 顺序特性 后进先出（LIFO） 栈的基本结构 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; stack\u0026lt;int\u0026gt; S;//定义一个栈 int main(){ S.push(1); //入栈 S.push(20); S.push(16); while(!S.empty()){ //当栈不为空 cout\u0026lt;\u0026lt;S.top()\u0026lt;\u0026lt;endl; //取出栈顶元素 S.pop(); //出栈 } return 0; } map # 通过 map\u0026lt;string, int\u0026gt; dict 来定义一个 key: value 映射关系的空的 map。当然 map 可以存任何类型的数据，比如 map\u0026lt;int, int\u0026gt; m 等等。\n操作类别 方法/函数 说明 插入元素 map[key] = val / insert({key, val}) 插入键值对（自动排序） 删除元素 erase(key) 删除指定键 查找元素 find(key) 二叉搜索查找，O(log n) 访问元素 map[key] 若不存在会创建新键 其他功能 size() / empty() 容器信息 自动排序 ✅ 按 key 升序排列 键唯一性 ✅ 不允许重复 key #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ map\u0026lt;string,int\u0026gt; dict; //定义一个空的map string key; int value; for(int i=0;i\u0026lt;5;i++){ cin \u0026gt;\u0026gt; key \u0026gt;\u0026gt; value; //输入键值对(这样赋值) dict[key]=value; //将键值对存入map中 } /* 使用迭代器遍历map的key和value */ for(map\u0026lt;string,int\u0026gt;::iterator it = dict.begin();it != dict.end();it++){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; //输出键值对 } /* 使用auto遍历map的key和value */ for(auto it = dict.begin();it != dict.end();it++){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; //输出键值对 } dict.clear(); //清空map return 0; } set # 通过 set\u0026lt;string\u0026gt; country 来定义一个空的存储字符串的 set。当然 set 可以存任何类型的数据，比如 set\u0026lt;int\u0026gt; s 等等。\n操作类别 方法/函数 说明 插入元素 insert(val) 插入自动排序的唯一元素 删除元素 erase(val) 删除指定元素 clear() 清空容器 查找元素 find(val) 二叉搜索查找，O(log n) 访问元素 只能通过迭代器 无下标访问 其他功能 size() / empty() 容器信息 自动排序 ✅ 升序排序 元素唯一性 ✅ 不允许重复元素 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { set\u0026lt;string\u0026gt; country; // 定义一个空的 set string name; // 输入字符串并存入 set 中 for (int i = 0; i \u0026lt; 5; i++) { cin \u0026gt;\u0026gt; name; country.insert(name); } // 使用迭代器遍历 set 的元素 for (set\u0026lt;string\u0026gt;::iterator it = country.begin(); it != country.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 输出 set 中的元素 } // 使用 auto 遍历 set 的元素 for (auto it = country.begin(); it != country.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 输出 set 中的元素 } // 删除 set 中的元素 country.erase(\u0026#34;China\u0026#34;); // 使用 find() 函数查找 set 中的元素 set\u0026lt;string\u0026gt;::iterator it = country.find(\u0026#34;China\u0026#34;); // 统计 set 中元素的个数 cout \u0026lt;\u0026lt; country.count(\u0026#34;China\u0026#34;) \u0026lt;\u0026lt; endl; // 输出 set 中元素的个数 // 使用 empty() 函数判断 set 是否为空 cout \u0026lt;\u0026lt; country.empty() \u0026lt;\u0026lt; endl; // 输出 set 是否为空 // 输出 set 中元素的 cout \u0026lt;\u0026lt; country.size() \u0026lt;\u0026lt; endl; // 输出 set 中元素的个数 使用 clear() 函数清空 set country.clear(); return 0; } unordered_map # 通过 unordered_map\u0026lt;string, int\u0026gt; dict 来定义一个 key: value 映射关系的空的 unordered_map。当然 unordered_map 可以存任何类型的数据，比如 unordered_map\u0026lt;int, int\u0026gt; m 等等。\n操作类别 方法/函数 说明 插入元素 umap[key] = val / insert({key, val}) 插入键值对（无序） 删除元素 erase(key) 删除指定键 查找元素 find(key) 哈希查找，平均 O(1) 访问元素 umap[key] 若不存在会创建新键 其他功能 size() / empty() 容器信息 自动排序 ❌ 无序存储 键唯一性 ✅ 不允许重复 key #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main(){ unordered_map\u0026lt;string,int\u0026gt; dict; //定义一个空的unordered_map string key; int value; for(int i=0;i\u0026lt;5;i++){ cin \u0026gt;\u0026gt; key \u0026gt;\u0026gt; value; //输入键值对(这样赋值) dict[key]=value; //将键值对存入unordered_map中 } /* 使用迭代器遍历unordered_map的key和value */ for(auto it = dict.begin();it != dict.end();it++){ cout \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; endl; //输出键值对 } dict.clear(); //清空unordered_map return 0; } unordered_set # 与 set/multiset 的区别在于元素无序，只关心 「元素是否存在」，使用哈希实现。\n操作类别 方法/函数 说明 插入元素 insert(val) 插入元素（无序，不重复） 删除元素 erase(val) 删除指定元素 查找元素 find(val) 平均 O(1) 查找 判断存在 count(val) 判断元素是否存在（0 或 1） 遍历元素 使用 for (auto x : uset) 无序遍历 其他功能 size() / empty() 获取大小 / 判空 元素唯一性 ✅ 不允许重复元素 自动排序 ❌ 无序结构，基于哈希表 共有函数 # 以下是 STL 容器中常用的共有函数：\n=：赋值运算符以及复制构造函数。 begin()：返回指向容器开头元素的迭代器。 end()：返回指向容器末尾下一个位置的迭代器（不指向具体元素）。 size()：返回容器中元素的个数。 max_size()：返回容器理论上能存储的最大元素个数（依赖容器类型和存储变量类型）。 empty()：判断容器是否为空。 swap()：交换两个容器的内容。 clear()：清空容器中的所有元素。 比较运算符： == / !=：判断两个容器是否相等或不等。 \u0026lt; / \u0026gt; / \u0026lt;= / \u0026gt;=：按字典序比较两个容器的大小（无序容器不支持这些运算符；map 的每个元素相当于 set\u0026lt;pair\u0026lt;key, value\u0026gt;\u0026gt;）。 一些注意点 # unordered_map 和 map 的区别\nunordered_map 是无序的，基于散列表实现，适用于元素不需要有序，对于单次查询时间不敏感的场景；\nmap 是有序的，基于红黑树实现，适用于元素需要有序，对于单次查询时间较为敏感的场景；\n需要保持 key 的有序性： map\u0026lt;string, int\u0026gt; student_scores; 需要做范围查找或区间查询： map\u0026lt;int, string\u0026gt; intervals; auto it = intervals.lower_bound(10); // 找到大于等于 10 的最小键 频繁遍历时需要有序输出: map\u0026lt;int, string\u0026gt; log_by_time; // 按时间戳排序的日志 unordered_map 的查找速度比 map 快，但是 unordered_map 占用的内存比 map 多。\n迭代器的使用 在 STL 中迭代器的行为模式与指针类似，迭代器可以用来遍历容器中的元素。 主要支持两个运算符：自增（++）和解引用（*）。\nvector\u0026lt;int\u0026gt; data(10); for (int i = 0; i \u0026lt; data.size(); i++) cout \u0026lt;\u0026lt; data[i] \u0026lt;\u0026lt; endl; // 使用下标访问元素 for (vector\u0026lt;int\u0026gt;::iterator iter = data.begin(); iter != data.end(); iter++) cout \u0026lt;\u0026lt; *iter \u0026lt;\u0026lt; endl; // 使用迭代器访问元素 // 在C++11后可以使用 auto iter = data.begin() 来简化上述代码 auto 关键字 auto 关键字用于自动推导变量类型，简化代码书写。可以用于声明变量、函数返回值等场景。属于 C++11 标准。但是使用时要注意以下几点：\nauto 只能用于局部变量，不能用于全局变量。 auto 不能用于函数参数和返回值。 auto 不能用于数组和函数指针。 auto 不能用于引用类型。 auto 不能用于 const 和 volatile 类型。 auto 不能用于模板参数。 ","date":"2025-05-19","externalUrl":null,"permalink":"/docs/algorithm/stl/","section":"文档","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg\n        class=\"my-0 rounded-md\"\n        loading=\"lazy\"\n        srcset=\"\n        /docs/algorithm/stl/image/index/1747656900325_hu2074340021832321260.png 330w,\n        /docs/algorithm/stl/image/index/1747656900325_hu6702968954444764840.png 660w,\n        /docs/algorithm/stl/image/index/1747656900325_hu17879524764861729221.png 1024w,\n        /docs/algorithm/stl/image/index/1747656900325_hu16640134181028556702.png 2x\"\n        src=\"/docs/algorithm/stl/image/index/1747656900325_hu6702968954444764840.png\"\n        alt=\"1747656900325\"\n      /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eAlgorithm 头文件 \n    \u003cdiv id=\"algorithm-%E5%A4%B4%E6%96%87%E4%BB%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#algorithm-%E5%A4%B4%E6%96%87%E4%BB%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eC++的算法头文件中有很多实用的函数\u003c/p\u003e\n\n\n\u003ch3 class=\"relative group\"\u003e排序 \n    \u003cdiv id=\"%E6%8E%92%E5%BA%8F\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%8E%92%E5%BA%8F\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esort()\u003c/code\u003e：对容器中的元素进行排序。依次传入三个参数，要排序区间的起点，要排序区间的终点+1，比较函数。比较函数可以不填，则默认为从小到大排序。\n也可以使用\u003ccode\u003egreater\u0026lt;type\u0026gt;()\u003c/code\u003e来实现从大到小排序，或者自定义比较函数。\u003c/p\u003e","title":"【算法】C++ STL的使用","type":"docs"},{"content":"一种新技术一旦开始流行，你要么坐上压路机，要么成为铺路石。——Stewart Brand\n","date":"2025-03-10","externalUrl":null,"permalink":"/posts/daily/2025-03-10/","section":"帖子","summary":"\u003cp\u003e一种新技术一旦开始流行，你要么坐上压路机，要么成为铺路石。——Stewart Brand\u003c/p\u003e","title":"2025 03 10","type":"posts"},{"content":"","date":"2025-03-10","externalUrl":null,"permalink":"/tags/%E6%AD%A5%E5%B1%A5%E4%B8%8D%E5%81%9C/","section":"Tags","summary":"","title":"步履不停","type":"tags"},{"content":" 日常 · 记录 · 想法 ","date":"2025-03-10","externalUrl":null,"permalink":"/posts/","section":"帖子","summary":"\u003cdiv class=\"lead text-neutral-500 dark:text-neutral-400 !mb-9 text-xl\"\u003e\n  日常 · 记录 · 想法\n\u003c/div\u003e\n\n\u003chr\u003e","title":"帖子","type":"posts"},{"content":" ONE # 二零二五年三月一日，晴\n三月来了，该听『米店』了\nTWO # 三月的烟雨 飘摇的南方\n你坐在你空空的米店\n你一手拿着苹果 一手拿着命运\n在寻找你自己的香\n窗外的人们匆匆忙忙\n把眼光丢在潮湿的路上\n你的舞步划过空空的房间\n时光就变成了烟\n爱人 你可感到明天已经来临\n码头上停着我们的船\n我会洗干净头发爬上桅杆\n撑起我们葡萄枝嫩叶般的家\nTHREE # 初春三月，又一年冬日已远去，万物复苏，人们也开始忙碌起来\u0026hellip;\n整首歌孤寂又美好，慢悠悠的旋律诉说着匆匆流逝的过往，斑驳的时光，烟雨中的南方。无论过去如何，尽管身处低谷，我们总要一路向前，不纠结过去，风轻而云淡~\n淡视挫折又向往未来！\nFOUR # 这几天用清单列出了待办事项和每日计划，再加上有人监督，完成的还不错，希望可以坚持下去！ 另外测试一下新添加的『图片轮播』功能，效果还不错，感觉观感比瀑布流相册更简洁美观~ Good Night! 🌙\n","date":"2025-03-01","externalUrl":null,"permalink":"/posts/daily/2025-03-01/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style = \"text-align: center;\"\u003e\n    \u003cp\u003e二零二五年三月一日，晴\u003c/p\u003e\n    \u003cp\u003e三月来了，该听『米店』了\u003c/p\u003e\n    \u003ccenter\u003e\n    \u003ciframe frameborder = \"no\" border = \"0\" marginwidth = \"0\" marginheight = \"0\" width = 400 height = 86 src = \"//music.163.com/outchain/player?type=2\u0026id=26494698\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n    \u003c/center\u003e\n\u003c/div\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cp style = \"text-align:center\"\u003e三月的烟雨 飘摇的南方\u003c/p\u003e","title":"2025 03 01","type":"posts"},{"content":"","date":"2025-03-01","externalUrl":null,"permalink":"/tags/%E6%97%A5%E5%B8%B8/","section":"Tags","summary":"","title":"日常","type":"tags"},{"content":"","date":"2025-03-01","externalUrl":null,"permalink":"/tags/%E9%9F%B3%E4%B9%90/","section":"Tags","summary":"","title":"音乐","type":"tags"},{"content":"","date":"2025-02-25","externalUrl":null,"permalink":"/tags/%E8%8A%82%E6%97%A5/","section":"Tags","summary":"","title":"节日","type":"tags"},{"content":"","date":"2025-02-25","externalUrl":null,"permalink":"/tags/%E8%87%B4%E8%87%AA%E5%B7%B1/","section":"Tags","summary":"","title":"致自己","type":"tags"},{"content":" ONE # 二零二五年正月廿八日，晴\n致自己的20岁\nTWO # Traveling Light\n第一次听这首歌是在 2019 年 3 月，它从高一陪伴我到现在，每次放假或出行都会专门找到这首歌，看着窗外的风景发呆。\n在你失落的时候，听一听《Traveling light》，释放心灵的重负 THREE # 致自己的 20 岁，希望新的一岁你可以 Traveling Light。\n","date":"2025-02-25","externalUrl":null,"permalink":"/posts/daily/2025-02-25/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style = \"text-align: center;\"\u003e\n    \u003cp\u003e二零二五年正月廿八日，晴\u003c/p\u003e\n    \u003cp\u003e致自己的20岁\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003ctext\u003eTraveling Light\u003c/text\u003e\u003c/p\u003e","title":"致自己的20岁","type":"posts"},{"content":"","date":"2025-02-19","externalUrl":null,"permalink":"/tags/llm/","section":"Tags","summary":"","title":"LLM","type":"tags"},{"content":"","date":"2025-02-19","externalUrl":null,"permalink":"/tags/study/","section":"Tags","summary":"","title":"Study","type":"tags"},{"content":" 本文主要介绍如何使用 LLaMAFactory 实现大模型微调，基于 Qwen2.5-7B-Instruct 模型进行 LoRA 微调\n基础概念 # 大模型训练流程 # ChatGPT 的训练流程 图中的 Reward Modeling 和 Reinforcement Learning 可以看做一步，即 RLHF，因此训练一个大模型一般可以分为三步：\n预训练（Pre Training，PT）：这一阶段是模型训练的基础，利用海量数据、大量算力通过无监督训练得到一个基础模型。预训练后的模型具备强大的语言生成能力，但由于它主要是无监督训练的结果，可能不会直接适应具体的任务（如问答、对话），需要进一步的微调。 监督微调（Supervised Fine-Tuning，SFT）：这一阶段则是对 Base 模型进行微调，让模型能够适用特定任务，最终得到一个 SFT 模型。 微调的目的是让模型更好地理解特定任务的需求。例如，通过使用对话数据集对模型进行微调，可以让模型在遇到问题时生成更相关的答案，而不是简单地生成与问题相似的文本。 这些问答对话由人类准备的，通常是有标签的，包含了问题和答案对，或者其他特定任务的数据。 强化学习（Reinforcement Learning form Human Feedback，RLHF）：这一阶段通过引入人类反馈（或者基于人类反馈训练的奖励模型）进一步优化模型的生成质量，使其生成的回答更符合用户的期望和人类的价值观。 一般按照 3H 原则进行打分： Helpful：判断模型遵循用户指令以及推断指令的能力。 Honest：判断模型产生幻觉(编造事实)的倾向。 Harmless：判断模型的输出是否适当、是否诋毁或包含贬义内容。 由于直接从人类获取反馈的成本较高，通常会先训练一个奖励模型（Reward Model，RM）来代替人类打分，这样可以在 RL 的框架下进行大规模的自动优化。 预训练由于对算力和数据需求都比较大，因此一般玩家不会涉及到预训练，更多的是基于开源的基础模型（LLama、deepseek、Qwen、ChatGLM…）做微调、强化学习以满足自身需求。\n模型名称各部分释义 # 以 Qwen1.5-14B-Chat-GQPT-Int4 为例，可以分为 5 个部分，具体含义如下图： 5 个参数含义如下：\n模型系列：一般一个公司、组织的模型都会归属于同一个系列，比如阿里的 Qwen 系列、Meta 的 Llama 系列，智普的 Chatglm 系列。 模型版本：一个系列的模型也会有多个版本，一般是有大更新时才会更新，比如 Qwen 系列就存在 Qwen、Qwen1.5、Qwen2.5 系列。 参数量：一般为 xx B，B 为单位，表示 10 亿参数，比如 7B 则是有 70 亿参数，72B 则是 720 亿参数。这个只是一个大致范围，比如 68 亿、72 亿参数的模型一般也叫做 7B。 微调：开源模型为了能够直接使用，一般会提供经过问答任务微调的版本，即 Chat 模型。 量化：为了降低内存占用有的也会提供量化版本，比如大模型一般使用 FP32/FP16 精度，即一个参数占 4 或者 2 字节，而量化则是将权重参数使用更低精度的格式来存放，比如量化为 FP8 则是只需要 1 字节，Int4 则只需要 4 位。 其中需要注意的就是是否经过微调、量化：\n基础模型：不带任意后缀，或者 -Base 后缀，就是预训练后未经过微调的原始模型，比如 Qwen1.5、Llama3。 SFT 模型：带特定领域任务后缀，比如 xxx-chat，就是对基础模型做了问答任务微调，比如 Qwen1.5-Chat、Baichuan2-Chat。 量化模型：它通过将模型中的高精度浮点数参数转换为低精度的整数参数来减少模型的存储和计算需求。这样做可以显著降低模型的内存占用，加快推理速度，并减少能耗。量化可以带来显著的效率提升，但也可能引入一些精度损失。 GGUF：GGUF（以前称为 GGML）是一种量化方法，允许用户使用 CPU 来运行 LLM，但也可以将其某些层加载到 GPU 以提高速度。 GPTQ：GPTQ 是一种 4 位量化的训练后量化（PTQ）方法，主要关注 GPU 推理和性能。 AWQ：是一种新格式（激活感知权重量化），它是一种类似于 GPTQ 的量化方法。AWQ 和 GPTQ 作为方法有几个不同之处，但最重要的是 AWQ 假设并非所有权重对 LLM 的性能都同等重要。也就是说在量化过程中会跳过一小部分权重，这有助于减轻量化损失。所以他们的论文提到了与 GPTQ 相比的可以由显著加速，同时保持了相似的，有时甚至更好的性能。 微调（SFT） # 大模型微调，通常指有监督微调（Supervised Fine-Tuning, SFT），是在预训练模型（一般称为“基座模型”）的基础上进行的训练过程。\n预训练模型通常已经掌握了广泛的语言知识和语义表示，但为了让模型在特定任务或领域上表现得更好，我们会在特定任务的数据集上对其进行微调。它在任务性能、领域适应性、数据利用效率和计算成本等方面具有显著的优势。\n微调方法分类 # 微调根据更新参数量的不同可以分为以下两种：\n全量参数更新 Full Fine-tuning（FFT）：即对预训练模型的所有参数进行更新，训练速度较慢，消耗机器资源较多。 参数高效微调 Parameter-Efficient Fine-Tuning（PEFT）：只对部分参数做调整，训练速度快，消耗机器资源少。 理论上，预训练和微调都可以做全量参数更新和部分参数更新，但是一般实际训练时都是 预训练 + 全量，微调 + 部分参数更新 这样组合的。\nFFT 的原理，就是用特定的数据，对大模型进行训练，将 W 变成 W′，W′相比 W，最大的优点就是上述特定数据领域的表现会好很多。但是可能造成训练的成本比较高和灾难性遗忘（Catastrophic Forgetting），在其他领域的能力变差。\nPEFT 主要想解决的问题就是 FFT 存在的两个问题，也是目前比较主流的微调方案。\nPERT 可分为三类：\n添加额外参数的 Addition-based（A） 类似适配器的方法（Adapter-like methods） 软提示（Soft prompts） 选取部分参数更新 Selection-based（S） 引入重参数化 Reparametrization-based（R） 常见的 PEFT 方法：BitFit、Prompt Tuning、Prefix Tuning、P-Tuning、P-Tuning V2、Adapter Tuning、LoRA、QLoRA、MAM Adapter、UniPELT、 Freeze tuning 等等 BitFit : 只更新模型中的 bias 参数或部分 bias 参数。 Prefix Tuning : 在模型输入前添加可训练的前缀向量。 Prompt Tuning : 在输入层加入提示词（prompt tokens）进行微调。 P-Tuning : 在模型的每层都加入可学习的提示词。 Adapter Tuning : 在 Transformer 的每一层插入小型的适配器网络。 LoRA (Low-Rank Adaptation): 通过在模型的权重矩阵中引入低秩结构来进行微调。 QLoRA(Quantized LoRA)：提出了 NormalFloat 数据类型, 通过量化降低基座模型的显存占用，使得 65B 模型在单 GPU 上可以完成训练。 训练框架选择 # 比较主流的几个微调工具：\nhuggingface/transformers：最基础的一个库，提供了丰富的预训练模型和微调工具，支持大多数主流的 NLP 任务（如文本分类、序列标注、生成任务等）。适合进行快速实验和生产部署，有着广泛的社区支持。 huggingface/peft：Parameter-Efficient Fine-Tuning，huggingface 开源的微调基础工具。 modelscope/ms-swift：modelscope 开源的轻量级微调框架，以中文大模型为主，支持各类微调方法。可以通过执行脚本进行微调，也可以在代码环境中一键微调。自带微调数据集和验证数据集，可以一键微调和模型验证。 hiyouga/LLaMA-Factory：全栈微调工具，支持海量模型和各种主流微调方法。支持运行脚本微调和基于 Web 端微调，自带基础训练数据集。除微调外，还支持增量预训练和全量微调。 NVIDIA/Megatron-LM：NVIDIA 开发的大模型训练框架，支持大规模的预训练和微调。适用于需要极高性能和规模的大模型训练和微调。 快速实验选择 Transformers 即可，超大规模的选择 NVIDIA/Megatron-LM，普通规模就选择使用较为简单的 hiyouga/LLaMA-Factory。\nSFT 微调准备 # 数据集的质量对模型微调至关重要，微调后模型效果 80%取决于 SFT 训练数据，少量高质数据要比大量低质或者普通的数据好很多。\n数据集格式 # 通常 1 万条左右的精标数据即可发挥良好的效果，在扩充数据规模时需要注意数据多样性，多样性的数据可以提高模型性能。 数据质量可以通过 ppl、reward model，文本质量分类模型等方式进行初步评估。经过人工进行后续筛选。\nALpaca 格式 # 指令监督微调数据集 # 指令监督微调（Instuct Tuning）通过让模型学习详细的指令以及对应的回答来优化模型在特定指令下的表现。 instruction 列对应的内容会与 input 列对应的内容拼接后作为人类指令，即人类指令为 instruction\\ninput，而 output 列对应的内容为模型回答。\n\u0026#34;alpaca_zh_demo.json\u0026#34; { \u0026#34;instruction\u0026#34;: \u0026#34;计算这些物品的总费用。 \u0026#34;, \u0026#34;input\u0026#34; : \u0026#34;输入：汽车 - $3000，衣服 - $100，书 - $20。\u0026#34;, \u0026#34;output\u0026#34; : \u0026#34;汽车、衣服和书的总费用为 $3000 + $100 + $20 = $3120。\u0026#34; }, 在上例中，人类的最终输入是：\n计算这些物品的总费用。 输入：汽车 - $3000，衣服 - $100，书 - $20。 模型的回答：\n汽车、衣服和书的总费用为 $3000 + $100 + $20 = $3120。 如果指定，system 列对应的内容将被作为系统提示词。\nhistory 列是由多个字符串二元组构成的列表，分别代表历史消息中每轮对话的指令和回答。注意在指令监督微调时，历史消息中的回答内容也会被用于模型学习。 下面提供一个 alpaca 格式 多轮 对话的例子，对于单轮对话只需省略 history 列即可。\n[ { \u0026#34;instruction\u0026#34;: \u0026#34;今天的天气怎么样？\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;今天的天气不错，是晴天。\u0026#34;, \u0026#34;history\u0026#34;: [ [ \u0026#34;今天会下雨吗？\u0026#34;, \u0026#34;今天不会下雨，是个好天气。\u0026#34; ], [ \u0026#34;今天适合出去玩吗？\u0026#34;, \u0026#34;非常适合，空气质量很好。\u0026#34; ] ] } ] 预训练数据集 # 大语言模型通过学习未被标记的文本进行预训练，从而学习语言的表征。通常，预训练数据集从互联网上获得，因为互联网上提供了大量的不同领域的文本信息，有助于提升模型的泛化能力。 预训练数据集文本描述格式如下：\n[ {\u0026#34;text\u0026#34;: \u0026#34;document\u0026#34;}, {\u0026#34;text\u0026#34;: \u0026#34;document\u0026#34;} ] 偏好数据集 # 偏好数据集用于奖励模型训练、DPO 训练和 ORPO 训练。对于系统指令和人类输入，偏好数据集给出了一个更优的回答和一个更差的回答。\n一些研究 表明通过让模型学习“什么更好”可以使得模型更加迎合人类的需求。 甚至可以使得参数相对较少的模型的表现优于参数更多的模型。\n偏好数据集需要在 chosen 列中提供更优的回答，并在 rejected 列中提供更差的回答，在一轮问答中其格式如下：\n[ { \u0026#34;instruction\u0026#34;: \u0026#34;人类指令（必填）\u0026#34;, \u0026#34;input\u0026#34;: \u0026#34;人类输入（选填）\u0026#34;, \u0026#34;chosen\u0026#34;: \u0026#34;优质回答（必填）\u0026#34;, \u0026#34;rejected\u0026#34;: \u0026#34;劣质回答（必填）\u0026#34; } ] KTO 数据集 # KTO 数据集与偏好数据集类似，但不同于给出一个更优的回答和一个更差的回答，KTO 数据集对每一轮问答只给出一个 true/false 的 label。 除了 instruction 以及 input 组成的人类最终输入和模型回答 output ，KTO 数据集还需要额外添加一个 kto_tag 列（true/false）来表示人类的反馈。\n多模态数据集 # 多模态数据集需要额外添加一个 images 列，包含输入图像的路径。目前我们仅支持单张图像输入。\nSharegpt 格式 # ShareGPT 格式中的 KTO 数据集(样例)和多模态数据集(样例) 与 Alpaca 格式的类似。 预训练数据集不支持 ShareGPT 格式。\n指令监督微调数据集 # 相比 alpaca 格式的数据集， sharegpt 格式支持 更多 的角色种类，例如 human、gpt、observation、function 等等。它们构成一个对象列表呈现在 conversations 列中。 下面是 sharegpt 格式的一个例子：\n{ \u0026#34;conversations\u0026#34;: [ { \u0026#34;from\u0026#34;: \u0026#34;human\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;你好，我出生于1990年5月15日。你能告诉我我今天几岁了吗？\u0026#34; }, { \u0026#34;from\u0026#34;: \u0026#34;function_call\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;calculate_age\\\u0026#34;, \\\u0026#34;arguments\\\u0026#34;: {\\\u0026#34;birthdate\\\u0026#34;: \\\u0026#34;1990-05-15\\\u0026#34;}}\u0026#34; }, { \u0026#34;from\u0026#34;: \u0026#34;observation\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{\\\u0026#34;age\\\u0026#34;: 31}\u0026#34; }, { \u0026#34;from\u0026#34;: \u0026#34;gpt\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;根据我的计算，你今天31岁了。\u0026#34; } ], \u0026#34;tools\u0026#34;: \u0026#34;[{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;calculate_age\\\u0026#34;, \\\u0026#34;description\\\u0026#34;: \\\u0026#34;根据出生日期计算年龄\\\u0026#34;, \\\u0026#34;parameters\\\u0026#34;: {\\\u0026#34;type\\\u0026#34;: \\\u0026#34;object\\\u0026#34;, \\\u0026#34;properties\\\u0026#34;: {\\\u0026#34;birthdate\\\u0026#34;: {\\\u0026#34;type\\\u0026#34;: \\\u0026#34;string\\\u0026#34;, \\\u0026#34;description\\\u0026#34;: \\\u0026#34;出生日期以YYYY-MM-DD格式表示\\\u0026#34;}}, \\\u0026#34;required\\\u0026#34;: [\\\u0026#34;birthdate\\\u0026#34;]}}]\u0026#34; } 偏好数据集 # Sharegpt 格式的偏好数据集同样需要在 chosen 列中提供更优的消息，并在 rejected 列中提供更差的消息。 下面是一个例子：\nOpenAI 格式 # OpenAI 格式仅仅是 sharegpt 格式的一种特殊情况，其中第一条消息可能是系统提示词。\nSFT 超参数调整： # 比如 10 万个样本 2-3 个 epoch 内为佳，2 ～ 5 万个样本 一般是 4-5 个 epoch 并且领域增强的 SFT 数据不需要太多，质量一定要把握好，一般的领域总结回复的任务几百条数据即可（ 个人经验 ），视情况而定;小数据量可以适当增大 epoch，让模型充分收敛。\n例如：EPOCH：100 条数据时, Epoch 为 15，1000 条数据时, Epoch 为 10，10000 条数据时, Epoch 为 2。\nEpochs：需要根据数据集多少动态调整，比如 100 条数据时, Epoch 设置为 15，1000 条数据时, Epoch 为 10，10000 条数据时, Epoch 为 2。 Learning Rate：根据不同微调方法 LR 也需要调整，对于 LoRA 的 peft 训练方式，同时可以适当增大 LR Global BatchSize：调整 bs 可以加快训练速度，但是也会增加显存占用，需要根据 GPU 资源调整。如增加 accumulate step 32 64，当分布式节点增多时可以进一步增加 batch_size，提高吞吐。 RLHF # RLHF 是一种训练方式，并不是类似 Lora 这种的训练方法，RLHF 可以分为三阶段：\nLanguage Model，LM：一个预训练语言模型 LM，对基础模型微调得到一个微调后的模型 使用人工标注的数据对预训练模型进行监督微调，以获得初始版本的生成模型。 Reward Model，RM：训练一个奖励模型 RM：训练一个奖励模型（Reward Model），用于评估生成模型的输出质量。 收集生成模型输出及其对应的人类反馈。这些反馈可以是评分、选择最佳输出、直接修改等形式。 使用这些反馈数据训练奖励模型，使其能够对生成的输出进行评分。 奖励模型通常是一个监督学习模型，通过最小化预测评分与人类反馈评分之间的差距进行训练。 Reinforcement Learning，RL：用强化学习 RL 方式微调 LM ：使用强化学习算法（如 PPO（Proximal Policy Optimization））进一步优化第一步中生成的模型，使其输出更符合人类反馈的期望。 使用初始生成模型产生输出，并通过奖励模型评估这些输出的质量 使用 PPO 算法，根据奖励模型的评分更新生成模型的参数。 PPO 是一种强化学习算法，旨在平衡探索和利用，通过限制每次更新的幅度，确保稳定性和效率。 算法优化生成模型的策略，使其输出在奖励模型的评分下不断提升。 反复进行生成、评估、优化的循环，逐步提高生成模型的性能。 DPO # RLHF 是一种复杂且通常不稳定的过程，首先需要拟合反映人类偏好的奖励模型，然后使用强化学习来微调无监督 LM 以最大化这一估计的奖励，同时避免与原始模型偏离过远。\n**直接偏好优化（DPO）**是一种简单的无强化学习的语言模型偏好训练算法。\n如何训练垂直领域大模型 # 因为 Chat 模型就是在 Base 模型基础上做了微调以适应对话任务，掌握了生成对话内容的能力的 SFT 模型，因此再对 Chat 模型做 SFT 触发 灾难性遗忘 风险就比较高，相比之下 Base 因为没经过微调，因为触发 灾难性遗忘 的风险会比较低。 因此选择哪种模型取决于我们的场景。\n青春版：Chat 模型 + SFT 资源消耗少、模型通用能力有所降低 完整版：Base 模型 + 增量预训练(Continue PreTraining) + SFT 资源消耗大、模型通用能力完整保留 最终一个完整的训练垂直领域大模型可以分为以下三步：\nContinue PreTraining(增量预训练) : 一般垂直大模型是基于通用基座大模型进行二次的训练，为了给模型注入领域知识，就需要用领域内的语料进行继续预训练。 SFT ( Supervised Finetuning,有监督微调): 通过 SFT 可以激发大模型理解领域内的各种问题并进行回答的能力(在有召回知识的基础上) 强化学习：一般是二选一 RLHF(奖励建模、强化学习训练): 通过 RLHF 可以让大模型的回答对齐人们的偏好，比如行文的风格。 DPO(直接偏好优化) 微调实例 # 服务器部署\n环境配置 创建虚拟环境 安装 LLaMAFactory\ngit clone -b v0.8.1 https://github.com/hiyouga/LLaMA-Factory.git cd LLaMA-Factory pip install -e .[torch,metrics] 准备模型 使用 Qwen2.5-7B-Instruct 模型进行微调\n# 安装并初始化 git-lfs apt install git-lfs -y git lfs install # 下载模型 git lfs clone https: //www.modelscope.cn/qwen/Qwen2.5-7B-Instruct.git 准备数据集 在 LLaMA-Factory 中，数据集的格式是一个 json 文件，每一行是一个 json 对象，根据项目需求，创建一个 Alpaca 格式的数据集\n[ { \u0026#34;instruction\u0026#34;: \u0026#34;判断用户的情感倾向(正面/负面/中性)。\u0026#34;, \u0026#34;input\u0026#34; : \u0026#34;输入：地铁十号线真挤\u0026#34;, \u0026#34;output\u0026#34; : \u0026#34;负面。是对交通出行舒适度的评价。\u0026#34; } ] 将新增数据集注册到 LLaMAFactory 中：\n将数据集移动到 data 目录下 修改 dataset_info.json 注册数据集 root@test: /LLaMA-Factory# cat data/dataset_info.json { \u0026#34;comments\u0026#34;: { \u0026#34;file_name\u0026#34;: \u0026#34;comments.json\u0026#34; }, } 开始微调 新版提供了 llamafactory-cli 命令行工具使用。\nmodelPath = models/Qwen1.5-1.8B-Chat llamafactory-cli train \\ --model_name_or_path $modelPath \\ --stage sft \\ --do_train \\ --finetuning_type lora \\ --template qwen \\ --dataset identity \\ --output_dir ./saves/lora/sft \\ --learning_rate 0.0005 \\ --num_train_epochs 8 \\ --cutoff_len 4096 \\ --logging_steps 1 \\ --warmup_ratio 0.1 \\ --weight_decay 0.1 \\ --gradient_accumulation_steps 8 \\ --save_total_limit 1 \\ --save_steps 256 \\ --seed 42 \\ --data_seed 42 \\ --lr_scheduler_type cosine \\ --overwrite_cache \\ --preprocessing_num_workers 16 \\ --plot_loss \\ --overwrite_output_dir \\ --per_device_train_batch_size 1 \\ --fp16 结果查看 # 查看 LoRA 权重 根据日志可以看到，微调后的模型保存到了我们指定的 ./saves/lora/sft 目录\n[INFO|trainer.py:3410] 2025-02-19 20: 51: 37, 168 \u0026gt;\u0026gt; Saving model checkpoint to ./saves/lora/sft root@lixd-sft: /LLaMA-Factory# ll -lhS ./saves/lora/sft 查看 loss 曲线 训练过程中会实时打印训练日志，其中就包括了 loss 信息，就像这样：\n微调参数 –logging_steps = 1 因为每一步都会打印日志\n{\u0026#39;loss\u0026#39;: 3.9236, \u0026#39;grad_norm\u0026#39;: 2.572678327560425, \u0026#39;learning_rate\u0026#39;: 8.333333333333333e-05, \u0026#39;epoch\u0026#39;: 0.09} {\u0026#39;loss\u0026#39;: 3.3305, \u0026#39;grad_norm\u0026#39;: 1.8977322578430176, \u0026#39;learning_rate\u0026#39;: 0.00016666666666666666, \u0026#39;epoch\u0026#39;: 0.18} {\u0026#39;loss\u0026#39;: 4.3762, \u0026#39;grad_norm\u0026#39;: 2.840055227279663, \u0026#39;learning_rate\u0026#39;: 0.00025, \u0026#39;epoch\u0026#39;: 0.26} ..... {\u0026#39;loss\u0026#39;: 0.1993, \u0026#39;grad_norm\u0026#39;: 0.9958950281143188, \u0026#39;learning_rate\u0026#39;: 2.052496544188487e-06, \u0026#39;epoch\u0026#39;: 4.66} {\u0026#39;loss\u0026#39;: 0.407, \u0026#39;grad_norm\u0026#39;: 1.3202508687973022, \u0026#39;learning_rate\u0026#39;: 5.136518124159162e-07, \u0026#39;epoch\u0026#39;: 4.75} {\u0026#39;loss\u0026#39;: 0.2622, \u0026#39;grad_norm\u0026#39;: 1.1825435161590576, \u0026#39;learning_rate\u0026#39;: 0.0, \u0026#39;epoch\u0026#39;: 4.84} 成功的训练一般有明显的收敛过程，且收敛出现在训练过程的后半部分都是合理的。\n1）如果没有明显收敛，说明训练不充分，可以增加训练 epoch 重训，或者进行增量训练。 2）如果收敛出现在训练过程的前半部分，而后部分的 loss 平稳无变化，说明可能有过拟合，可以结合评估结果选择是否减少 epoch 重训。 3）如果有收敛趋势，但没有趋于平稳，可以在权衡通用能力和专业能力的前提下考虑是否增加 epoch 和数据以提升专业能力，但会有通用能力衰减的风险。 可以看到，在训练到 70 步再往后的时候已经收敛了，看起来本次训练效果还可以。 参考资料 # 大模型微调实战\n","date":"2025-02-19","externalUrl":null,"permalink":"/docs/study/20250219_qwen_fine_tune/","section":"文档","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文主要介绍如何使用 LLaMAFactory 实现大模型微调，基于 Qwen2.5-7B-Instruct 模型进行 LoRA 微调\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e基础概念 \n    \u003cdiv id=\"%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e大模型训练流程 \n    \u003cdiv id=\"%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eChatGPT 的训练流程\u003c/strong\u003e\n\n    \u003cfigure\u003e\n      \u003cimg\n        class=\"my-0 rounded-md\"\n        loading=\"lazy\"\n        srcset=\"\n        /docs/study/20250219_qwen_fine_tune/imgs/01_hu7432936583427614731.png 330w,\n        /docs/study/20250219_qwen_fine_tune/imgs/01_hu6483044369201846705.png 660w,\n        /docs/study/20250219_qwen_fine_tune/imgs/01_hu10302658420192218926.png 1024w,\n        /docs/study/20250219_qwen_fine_tune/imgs/01_hu5206765031144962701.png 2x\"\n        src=\"/docs/study/20250219_qwen_fine_tune/imgs/01_hu6483044369201846705.png\"\n        alt=\"\"\n      /\u003e\n      \n    \u003c/figure\u003e\n\n图中的 Reward Modeling 和 Reinforcement Learning 可以看做一步，即 RLHF，因此训练一个大模型一般可以分为三步：\u003c/p\u003e","title":"使用 LLaMAFactory 实现大模型微调","type":"docs"},{"content":"To：Myself\n新年快乐！\n这是一封迟来的信，来自春节后返校的你。在新的一年里，祝你万事顺意，继续做一个善良乐观的男孩，不要质疑自己，质疑未来。过去的一年是甜酸苦辣的一年，用物理学知识来解释：“生活中，有一些事情是不可逆的，就像熵增原理，事物总是向无序的方向发展，一切都是会变的。如果你想要维持生活的秩序，那就要付出一些去做功。”然后呢，不要留恋过去，也不要畏惧未来，20年里你经历了很多，成长了很多，现在分割线到了，从今年起，你就是20+了，不要再像小孩一样幼稚经不起拷打了，未来的考验会更多，但是相信你会越来越好的！\n接下来，展望一下未来吧！新年的新FLAG就是拍更多的照片，追寻属于自己的25#底片！\n小时候不喜欢拍照，害怕镜头，总是会感到局促不安。就连高考完捧着鲜花也没拍几张可入眼的照片，仅有两张还是班主任抓拍的，其中一张还端着大碗面条。当时觉得蠢呼呼的照片，但是上大学以后翻出来看，却觉得过去真好，记录真好。\n上大学以后，去了小时候觉得遥不可及的香港、南京、武汉、长沙\u0026hellip;\u0026hellip;每到一个地方，看到从未见过的另一种风景、另一种生活，都会让我从现实中逃离出来，享受这短暂的轻松，我会望着美景做白日梦，幻想不久的将来，有人相伴，走遍更多的地方，捕捉更多的美景。当然你也发现身边处处有美景，就算平平无奇的水沟，在日落时分也巨美！于是你开始鼓捣谷歌相机，开始尝试各种滤镜。之前连掏出手机拍摄都羞涩的你变得更加自信，慢慢地你刷到越来越多的摄影视频和帖子，你喜欢上摄影的仪式感，你开始盘算奖学金的分配，开始挑选属于自己的相机。终于在2024年底，梦想成真，你的人生清单又多了一个对勾。\n在网上刷到这样一段话：\n无论你手上用的是哪一台相机，我都由衷的建议你走出去，去看看这个美丽的世界，欣赏久未凝视过的日出和日落，还有城市里难能一见的满天星辰，灿烂星河，按下快门，去拍下你眼中看到的曼妙风景，去记录你所在乎的人和事。只有这样，相机的参数才被赋予了真正的意义。\n相机带来的是仪式感，是催促你欣赏身边的美，远处的美，是让你记录下短暂的美好，定格瞬间。\n这个寒假你凌晨骑行，拍到了海边的日出，太阳升起的那刻，你变成了一个崭新的人；\n你拍了动物园的小动物，发现世界上不仅有很多怪异的人，还有这么多怪异的生物；\n回家了，你又拍了爸妈包饺子、贴对联、全家福，你发现人文也是一种风景；\n夜晚，你发现不让放烟花也许是个好事，仰望星空，发现并不是长大后星星少了，而是人们抬头的频率少了，你学会了间隔拍摄，第一次合成了星轨，接着你朝向北极星，望着一道道圆弧心中澎湃，你并不是个无聊的人，你有很多有趣的地方，也有很多奇怪的爱好；\n可能是因为最近看了太多宇宙相关的电影，你对拍星星拍月亮兴趣很大，尽管资金不够没舍得买长焦，但你学会了裁切，想要什么自己裁，于是你切到M档，调好参数，对准月亮，50mm的焦距下，月亮那么丁点，但是裁切后，月亮的细节竟然出乎意料的清晰，你又学了堆栈，妄图合成更具细节的月亮照片，但是裁切过细节不够效果一般，不过你还是很开心；\n人有悲欢离合，月有阴晴圆缺，当你把视线放远，看看远方，你会发现之前经历的一切都多么渺小，时间会模糊记忆，你并不需要沉迷于过去；月亮弯弯，月球下的人不满足，隔了几天他又装上三脚架开始拍摄，几天又几天，等到了十五晚上，月离圆圆，你有些遗憾，十五的月亮十六圆，但你十六就回学校了，但你很幸运，2025年的月亮十五21时53分最圆；\n你和家人又去了磁州水墨园，日落的时分，阳光很美，Golden Hour\u0026hellip;\u0026hellip;寒假很愉快，你懂得了记录的意义，每一张照片都有自己的回忆，你会继续记录下去，当一个日记本，记录人生的所见所闻。\n今天，你重刷了《白日梦想家》，你明白白日梦虽好，却只是逃避，所以希望你不要消沉，在追寻属于自己的25号底片的道路上步履不停。\n愿新的一年，日日自新，在成长的道路上步履不停，无限进步！\nYan Hyoung\n2025年2月18日，于嘉定\n","date":"2025-01-01","externalUrl":null,"permalink":"/posts/daily/2025-01-01/","section":"帖子","summary":"\u003cp\u003e\u003cstrong\u003eTo：Myself\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e新年快乐！\u003c/p\u003e\n\u003cp\u003e这是一封迟来的信，来自春节后返校的你。在新的一年里，祝你万事顺意，继续做一个善良乐观的男孩，不要质疑自己，质疑未来。过去的一年是甜酸苦辣的一年，用物理学知识来解释：“生活中，有一些事情是不可逆的，就像熵增原理，事物总是向无序的方向发展，一切都是会变的。如果你想要维持生活的秩序，那就要付出一些去做功。”然后呢，不要留恋过去，也不要畏惧未来，20年里你经历了很多，成长了很多，现在分割线到了，从今年起，你就是20+了，不要再像小孩一样幼稚经不起拷打了，未来的考验会更多，但是相信你会越来越好的！\u003c/p\u003e","title":"2025 01 01","type":"posts"},{"content":"","date":"2025-01-01","externalUrl":null,"permalink":"/tags/25%23%E8%83%B6%E7%89%87/","section":"Tags","summary":"","title":"25#胶片","type":"tags"},{"content":" 2024 操作系统期末复习 # Tongji University. 2024/12/28\nAuthor: Hyoung Yan\n本文框架 # 外设管理 # 外设管理，文件管理 Unix V6++源代码不用看。操作流程方面，特别细节的地方不用看。比如，要掌握核心数据结构，磁盘高速缓存池。借助缓存的读写操作，缓存块互斥使用的过程，缓存队列的变化。\n外设基础概念 # CPU 访问内存和访问外设是不一样的 内存中的信息每个字节有物理地址。以字节为单位随机访问。访问方式：CPU 将物理地址放在地址总线上，直接访问。 外设中的信息没有地址，不能直接访问，需要使用特殊的方式（in、out 指令或内存映射），先将外设中的数据取入内存或寄存器，再进行访问。外设中的字节 不能随机访问 键盘、网络输入信息是流式的，读完一个字节才能读下个字节 硬盘中的信息按扇区组织，扇区 512 字节，全读出来或者被新数据块覆盖。 计算机与外设的交互 外设一次执行一条 IO 命令，完成或失败后，CPU 才能发下条命令。 读操作 I：外设转换好的数据放在数据缓存中，供计算机读取 写操作 O：计算机将数据放在数据缓存中，外设将其中的数据转化成物理信号向外界输出 外设控制器的寄存器（端口），以磁盘为例\nCPU 写命令端口向外设发 IO 命令\n读命令 out 0x00000003, comPort 写命令 out 0x00000001, comPort CPU 读状态端口（in 指令）获取外设状态\nbusy 标志为 1，IO 命令执行中，CPU 暂停指令发送，直到 busy 位为 0 done 标志为 1，IO 命令执行完毕，CPU 可以读取数据 error 标志为 1，IO 命令执行出错，CPU 可以读取错误信息 CPU 读数据端口取数据缓存中的数据（外设的输入数据）；写数据端口向数据缓存中写数据（外设的输出数据）\n三种外设控制方式\n程序直接控制 IO 方式 1（忙等，读） CPU 承担全部 IO 事务：忙等外设空闲、IO 完成，计算和 IO 无法并行。 CPU 只能忙等一个外设，整个系统 IO 效率低下，多个外设无法并行工作。 程序直接控制 IO 方式 2（轮询 polling） 程序在合适的时间点主动查看外设状态（发出请求时，设备忙，离开；IO 未完成，离开），计算和 IO 能够并行，多个外设可以并行，但 CPU 仍然需要承担所有的外设事务。 中断驱动的 IO 方式 中断是 IO 完成信号。CPU 无需忙等或轮询 IO 操作。计算和 IO 可以并行。不同的外设，IO 也可以并行。 数据块从外设数据缓存复制到内存的工作由 CPU 完成。所以，中断驱动的 IO 方式只适合键盘、鼠标等数据缓存很小的外设 在中断驱动的 I/O 方式中，外设的操作（如数据输入输出）不会像轮询（Polling）那样周期性地检查外设的状态，而是 由外设主动发出中断信号，通知操作系统有需要处理的任务。 DMA 方式（磁盘、网络、GPU\u0026hellip;） 数据就绪于外设数据缓存后，外设控制器向 DMA 控制器发中断信号 DMA 控制器循环，盗取主存周期，把数据缓存中的数据送入内存，一次传送一个字。这一步会循环直至内存得到数据缓存中的所有数据所有数据传送完毕后，DMA 控制器向 CPU 发中断信号。 终端处理程序不复制数据，CPU 完全不参与数据传输 缓存 # 只考磁盘的块设备缓存，字符设备不考，把复习题中的状态图看懂，识别出 IO 请求队列，自由缓存队列 磁臂调度算法，磁盘访问时间，计算所在磁道\n内存中为每个外设配缓存，暂存外设 IO 数据；缓存在 核心空间，Unix v6++中，缓存在内核数据段。 块设备（存储设备）用于信息存储，例如硬盘、软盘、光盘等，数据存储以数据块为单位，缓存是磁盘高速缓存池，可重用的字符块集合。 UNIX V6++，缓存块 512 字节，同步磁盘上的 1 个扇区。缓存块中存放的那个数据块所有 进程共享，互斥访问。用前上锁，用后解锁。 借助缓存的读写操作 写入数据量不足一个数据块，先读后写 buffer[offset] = a 写入一整块，无需先读 buffer = 数组a 内核会在合适时机，将缓存中的数据块写回磁盘（持久化操作）；什么时候？最晚，关机时，需要把新数据写回磁盘。装新数据的是 脏缓存块。写回磁盘前，如果断电，磁盘会丢数据。 性能分析 用户空间 IO 的使用场合 Unix V6++的磁盘高速缓冲池\n缓存控制块：m_Buf [i] 是 Buffer [i] 的控制块\nb_dev：磁盘号 b_blkno：扇区号 b_wcount：IO 参数，传送字节数 b_addr：缓存块首地址 b_flags：缓存块状态 b_error：错误码 b_resid：IO 错误时剩余字节数 缓存管理：进程 随机读写 缓存池中的数据（任意数据块，从任意偏移量开始的任意字节） 新请求放队尾，前一个 IO 请求完成的时候启动下一个 IO 请求 如果仅考虑读操作，IO 子系统 FIFS 地为系统提供缓存不命中的数据块。 读是同步请求，影响 IO 系统响应速度，优先级高。 脏缓存块需要写回磁盘，防止数据丢失。写操作是异步的，优先级低。 Unix V6 写操作执行时机： 脏缓存块分配用来装新数据块时写回磁盘。 每 30s 执行一次 update 程序，将所有脏缓存块写回磁盘。 LRU 的自由缓存队列 Unix 的外设和缓存管理 所有磁盘共用磁盘高速缓冲池，每张磁盘有自己私有的设备缓存队列和 IO 请求队列。 外设管理和块设备管理 块设备开关表 bdevsw 管理所有块设备，每一个元素管理一种块设备 字符设备开关表 cdevsw 管理所有终端。每个元素管理一种终端 class BlockDevice { public: // 设备驱动 virtual int Open(short dev, int mode); virtual int Close(short dev, int mode); virtual int Strategy(Buf* bp); // 执行IO操作 virtual void Start(); // 向磁盘发IO命令 public:// n，同类磁盘的数量 Devtab* d_tab[n]; // 块设备表 }; class Devtab // 块设备表 { public: int d_active;// 磁盘忙，IO请求队列非空 int d_errcnt;// 队首IO操作，出错次数 Buf* b_forw; // 设备缓存队列队首 Buf* b_back; Buf* d_actf; // IO请求队列队首 Buf* d_actl; }; 主硬盘。设备号 0，0。 管理硬盘的内核对象：g_ATADevice ATA 硬盘驱动程序\n编程 DMA 控制器：设置内存物理地址，数据传输量\n写 PRD 表。PRD 表，最多 10 项。每一项是一个 PRD（Physical Region Descriptor，物理内存区描述符），管理 DMA 操作访问的一块连续内存区域。 编程磁盘控制器：设置需要 IO 的磁盘扇区号，扇区数 字节分解：bp-\u0026gt; b_blkno 是一个 32 位的整数，需要拆解为 4 个字节。每个字节包含 8 位，因此通过移位操作可以提取每个字节的具体值。 控制端口：IOPort:: OutByte 函数每次只能发送一个字节（8 位数据）。为了将 32 位的数据分解为多个字节，并通过多个端口传输，需要使用移位操作获取每个字节。 向磁盘控制器和 DMA 控制器发 IO 命令 磁盘中断处理程序 ATADriver::ATAHandler 同步读 bp = Getblk(dev,blkno) 申请使用缓存池中的数据块 Brelse(Buf* bp) 释放数据块的使用权 异步写\n数据写入缓存池后，解锁缓存块，写操作完毕。数据块可供其它进程使用。需要注意的技术细节：\n如果写入磁盘数据块的数据量不足 512 字节。先读后写，保护磁盘数据块中新数据覆盖不到的旧数据。 数据块写满时刷回磁盘。这是假定进程会顺序写磁盘数据，数据块写至底部不再有重用价值，异步写回磁盘。 若写不满，打脏标识、解锁缓存块，写操作完毕。 总结 Unix V6++外设管理模块和缓存管理模块 IO 性能优化（机械硬盘） # 机械硬盘（等速圆周运转的设备）\n每个盘面上有许多同心磁道，用于存储信息，从外至内编号为 0，1，2，3 等。 所有盘面上 相同编号的磁道组成一个柱面，柱面号即为磁道号。 每个磁道被划分为多个等圆心角的圆弧，每个圆弧为一个 扇区，编号为 0，1，2，3 等。 每个磁盘有上下两个盘面，每个盘面配有一个读写磁头，磁头号，磁头编号为 0，1，2，3 等。 磁盘的信息存储和访问单位为 扇区，目前的技术标准是每个扇区存放 512 字节。扇区的物理地址由柱面号、磁头号和扇区号组成。通过序列化可以得到扇区的逻辑地址。\n硬盘访问耗时：从 CPU 写命令寄存器至 → 数据块（512 字节）进硬盘控制器数据缓存\n寻道时间（seek time）：磁头从当前柱面移动到目标柱面的时间。平均寻道时间小于 10ms。 旋转延时（Rotational delay）：磁头到达目标柱面（磁道）后，等待欲访问扇区转到磁头之下。平均旋转延时为磁盘旋转一周所需时间 T 的 1/2。 数据传输时间（Data transfer）：磁头走过目标扇区，期间读扇区内容至硬盘数据缓存。若每个磁道包含 N 个扇区。数据传输时间为：T/N。 磁盘 IO 性能优化\n磁臂调度算法优化寻道时间 FIFO（FIFS） SSTF（Shortest Service Time First） SCAN（电梯调度算法） 算法性能比较\nSSTF 性能较好，但可能出现 被饿死的 IO 请求。 SCAN 和 C-SCAN 理论上不会饿死 IO 请求，但是会出现“磁臂粘着”（Arm stickiness）现象。指：一个或几个进程对某个柱面密集访问，反复读写其中的磁道，导致磁臂停留此处不动，其余进程针对其它柱面的 IO 请求会长期得不到处理。 解决方法：设置多个磁盘 IO 请求集合 优化旋转延迟（硬件） 考虑数据定位开销，优化文件访问速度：文件在磁盘上尽量连续存放。swap 分区上的进程图像一定要连续存放。\n预读技术 复习重点 # 说明操作系统进程设备管理的初衷？ 因为很麻烦，所以访问外设特别慢。计算机系统在设计时需要有效解决 CPU 访问内存和外设信息不一致的问题，提高系统的整体性能和响应速度。 设备管理中，I/O 软件的组成？什么是设备驱动程序？其主要完成什么功能？介绍 I/O 管理的流程。 I/O 硬件技术中，数据传输技术有那些？分别介绍？并说明中断技术和 DMA 技术的区别与联系？ 进程通信 # （1）读者、写者公平的解，不要求掌握 （2）复习资料里，明确写明不要求掌握的，考前肯定不需要看。 （3）银行家算法，资源释放算法不要求能够写出来。 银行家算法，Dijstra 1965 年提出。 算法的缺点（1）每次资源分配时实施，比较耗时（2）保守。进程提出的资源需求量很可能大于需要量。并且算法假定任何进程均可能随时提出资源申请（3）必需事先知道每个进程的最大资源需求量，工程上很难办到，所以这是一个理论上的算法。 数据库系统写操作日志、不预防死锁。 发现死锁之后（1）重启（2）恢复最近检查点，回放其后所有日志。 嗜眠理发师，PPT part 5 进程通信 2 个 银行家算法是死锁避免算法 预读不考\n可执行存储器是用来存放进程图像的存储单元，包括 内存 和 盘交换区。\n内存中的进程图像可以执行，因为每个单元都有物理地址 盘交换区中的图像不可执行，运行前必须要为其分配内存 内存中的进程 SLOAD = 1，盘交换区中的进程 SLOAD = 0 可执行存储器的使用状态\n可执行存储器的使用状态 RunIn，内存无法容纳，RunOut，内存可以容纳 进程在内存或盘交换区的驻留时长 Process 结构中设置 p_time 字段 设置 0#进程负责进程换入任务 互斥、同步、信号量 # 并发访问时，共享变量的值为什么会出错?(单核)\n现运行的应用程序 PA 执行完每条指令后，可能因为响应中断放弃 CPU。\n下台时，保存所有用户态寄存器。 被调度、再次运行时，恢复上次保存的用户态寄存器。 若某寄存器存有共享变量的更新，放弃 CPU 时，其它进程看不到更新，会读到过时的旧值。再者，若放弃 CPU 时段，其它进程 PB 有更新该变量，待 PA 再次上台，恢复寄存器时会覆盖 PB 对共享变量的更新。变量的值就会出错。 怎样保证共享变量的值不出错？\n上锁，保证更新共享变量是 原子操作。上例：counter++，一次完成。 并发进程互斥访问共享变量。用前上锁，用后解锁。访问期间，禁止其它进程的并发访问请求。 互斥、临界资源、临界区\n互斥：一次只允许一个进程使用。 需要互斥保护的叫做临界资源，包括 共享变量（数据结构）和计算机系统中所有的外部设备。 临界区是访问共享变量的那段代码。 锁的实现\n互斥机制应遵循的原则（假设，进程 PA 需要访问共享资源 R）\n空闲让进：R 空闲，可以使用 忙则等待：R 有进程用，等 有限等待：不可以等太久 让权等待：若要等待，入睡放弃 CPU （睡眠锁，适用于临界区很长或临界区内进程有可能入睡的情况） 软件实现的锁 关中断\n没有中断，就没有调度。 内核可以用关中断的方法实现原子操作。 应用程序可以使用的锁（硬件） 信号量 semaphore\n现代操作系统为应用程序提供的同步和互斥工具\n信号量的用法：\n为共享资源 R 配一个信号量，用来描述资源使用状态 semaphore semphoreR; 进程访问共享资源前，执行 P 操作，同步等待资源访问权限。 访问结束后，执行 V 操作，释放资源访问权限、唤醒等待使用资源的另一个进程 用信号量实现的互斥锁\n互斥信号量初值为 1，又叫 互斥锁。 int count = 0 ; semaphore mutex ； //保护共享变量 count mutex.value = 1 ; 同步 同步表现为并发系统中，经常需要：\n观察系统状态，确定自己是不是可以继续前进 修正系统状态，维护系统咋混给他一致性 实施同步的位置叫做 同步点 用信号量实施同步：设置同步信号量，维护系统状态，在同步点上：\n进程检测、更新系统状态，识别共享资源使用状态，必要时入睡、同步等待访问权限。核心是原子操作 P。 资源访问结束后，进程修正系统状态，释放资源访问权限、唤醒等待使用资源的其它进程。核心是原子操作 V。 经典 IPC 问题 1 (InterProcess Communication) # 引例一：吃水果 引例二：消息队列（多客户机、单服务器、无界缓存） 生产者、消费者问题 死锁：并发系统中，因资源管理不当导致的进程彼此等待，均无法前进的现象。\n产生死锁的情形 读者/写者问题\n共享变量需要互斥访问，但是读操作是可以并发的，允许读操作并发可以提高并发系统的效率。 读操作，不会改变共享变量的值 写操作，改变共享变量的值，两种写操作：更新 和 赋值 状态分析\n写操作必须互斥，不能与其他操作并发， 用一个互斥信号量就能搞定 读操作可以和读操作并发，不能与写操作并发，实现上，我们需要一个读者计数器 读者数量非 0 时，新的读操作可以并发，否则必需与写操作互斥 细节：读者计数器是一个共享变量，需要一个互斥信号量予以保护 读者有优先权的解决方案\n存在的问题：饿死写进程 写进程优先的解决方案 例子 经典 IPC 问题 2 \u0026amp; 死锁 # 嗜眠理发师 # 信号量的局限性，快餐店问题 嗜眠理发师问题 信号量的局限性 原始设计问题 seat 信号量的值表示空座位的数量，消费者每次进入时都会调用 p(seat)，如果座位满了（信号量为 0），进程会被阻塞。然后，进程执行完 eating 后释放信号量（v(seat)）。\n问题：\n信号量的值反映的是空座位数，而信号量本身并没有明确控制座位的数量，而只是作为一个计数信号量来管理等待队列。信号量的计数只适用于“占用资源”或“允许访问资源”，但它不能存储座位数。\n没有互斥机制：多个消费者进程可能会在“取座位”和“释放座位”这两个操作之间发生竞态条件。假设两个顾客同时到达并试图访问座位时，他们可能同时看到座位满了（seat == 0），但这时两者的 seat 数可能已经被错误地更新或冲突，从而导致座位的数量被错误管理。\nsemaphore mutex = 1; // 用于保护共享资源seat的互斥 int seat = n; // 座位数量 customer进程： p(mutex); // 获取锁 if (seat == 0) // 如果没有空座位 { v(mutex); // 释放锁 goto out; // 跳转到退出 } else { seat--; // 减少空座位数量 v(mutex); // 释放锁 } eating; // 顾客吃饭 p(mutex); // 重新获取锁 seat++; // 增加空座位数量 v(mutex); // 释放锁 out: exit; // 退出 理发店 失眠理发师 死锁 # 在一个进程集合中, 每个进程都因等待永远不会发生的事件而阻塞，称这种系统状态为死锁。 死锁产生的原因：资源竞争，资源分配策略导致进程推进顺序不当。 死锁的必要条件 系统的固有属性，不可破坏： 互斥条件：资源不可共享（软件：锁；硬件：所有外设） 不可剥夺条件：指进程已获得的资源在未使用完之前，不能被剥夺，只能使用完自己释放 破坏其中之一，就可以避免死锁： 请求和保持条件：进程先申请一部分资源，再申请另一部分资源。在无法获得新的资源的时候，不放弃已有资源 循环等待条件：资源分配图里有环路 处理死锁的方法 复习重点 # 为什么要引入进程？为什么要引入线程？从调度性、并发性、拥有的资源以及系统开销等方面，区别和比较进程和线程？ 进程状态迁移图，引起状态迁移的原因和事件？ 进程组成？PCB 的含义？ 进程之间的关系？什么是临界区？如何实现临界区的互斥访问？ P/V 操作的含义？信号量的含义？如何定义信号量的初值？如何利用 P/V 操作实现多个进程之间的同步和互斥？如利用其实现单缓冲区的读写问题？如何实现生产者消费者等问题？ 高级通信方式中，理解 send()和 receive（）的工作过程。 有哪些常用调度算法？引起进程调度的事件有那些？多级反馈队列调度算法的分析？ 引起死锁的四个特征是什么？如何针对这是个特征克服死锁？资源分配图的方法判定死锁？ 内存管理 # 思考题，考前不看 段式，段页式不考! md\n基本概念 # 多级存储器结构 存储管理终极目标：统一管理不同层次的存储介质。为系统提供容量近似于磁盘，访问速度近似于 cache 的物理存储器 存储管理的任务 存储资源管理：空闲资源管理、存储空间分配和释放 提供地址重定位机制：将指令和数据的逻辑地址转化为内存单元的物理地址 提供内存保护机制：防止现运行进程破坏内核或分配给其它进程的内存单元，以非法方式访问进程图像 内存扩充：借助大容量辅存扩充物理内存容量，存放暂时不用的进程图像。为系统提供一个容量比物理内存大许多的可执行存储器，以容纳更多的进程图像。 存储管理方式 # 为进程图像分配连续物理空间 所有图像均在内存的进程才能够执行 移动时搬迁的是整个进程图像。包括内存中的移动和换入、换出操作 可变分区 每个分区放一个进程。分区不固定。 用 空闲分区表（map 数组） 登记所有空闲分区的首地址和长度。 地址重定位和内存保护 内存扩充 优缺点 概念\n逻辑地址：程序中指令 和 数据的地址。编译、链接过程确定的。 物理地址：指令和数据在物理内存中的地址。操作系统内核决定的。 虚空间（地址空间），逻辑地址集合。 线性地址空间：进程可以访问的所有逻辑地址 = 应用程序的虚空间 ∪ 内核的虚空间。 物理地址空间，物理地址集合。 重定位（Relocate）：将可执行程序中，指令和数据的逻辑地址转换成物理地址。 静态重定位：由软件实施，程序加载时 动态重定位：动态重定位由 CPU 硬件，每次访存时实施：MMU 将逻辑地址转换成物理地址。 内存分配方式 连续内存分配方式 段式内存管理 为每个逻辑段独立分配物理内存空间，每个进程一张段表，登记所有逻辑段的 首地址，长度 和 保护位。 段是自然的共享、保护单位 段式内存管理的内存分配：内存分配，以自然段为单位，自然段长度可变，内存分配麻烦，存在外部碎片问题，物理内存利用率低。 页式存储管理方式 虚空间等分为若干个逻辑页面，逻辑页面(2^n)字节\n实空间（物理内存），按相同尺寸分为若干个页框\n允许为逻辑页面分配任意空闲的物理页框。\n每个进程一张页表（Page Table），登记所有逻辑页面的 物理页框号 和 保护位。\n每个逻辑页面一个页表项（Page Table Entry，PTE）\nbase 是分配给它的物理页框号\nprot 是保护位：\nU/S：1 (U) 表示应用程序的逻辑页，CPU 用户态运行时有权访问；0 (S) 表示内核的逻辑页，CPU 用户态运行时无权访问。 RW/RO：1 (RW) 表示可读、可写；0 (RO) 表示只读。 X：1 表示代码页，可执行；0 表示数据页，不可执行。 逻辑地址和页表 地址映射和内存保护 页式存储管理的优点\n页式最显著的优点，提高物理内存的利用率。每一个物理页框可以用来存放任何进程的任意逻辑页面。不存在 外部碎片 问题。但是存在页内碎片问题。 扩展进程图象极其容易，已有进程不必移动。（栈从高地址向低地址增长，堆从低地址向高地址增长） 以页为单位共享和保护物理内存 页式存储管理的缺点\n页表太大，页表项太多，页表占用内存空间太大。 页表查找时间太长，页表查找时间太长，页式地址映射，访存耗时加倍，CPU 运算速度减半。 CPU 的 Cache 指令缓存和数据缓存 命中：\n不命中： 物理地址访存耗时：指令/数据缓存访问时间 + 缓存不命中的概率 * 主存访问时间 TLB（装 PTE 的缓存） EAT（Effective Access Time，内存有效访问时间） 空闲分区管理 虚拟存储器 # 程序运行的局部性原理：时间局部性和空间局部性 虚拟存储器改善性能的思路 传统存储管理方式，一次性为进程图像分配所需的所有内存 仅为当前需要访问的代码和数据分配内存。现在主流的方法：在基本的分页机制的基础上，加上 调页机制 和 页面置换机制 调页机制：为即将访问的页面分配存储空间、并且进行初始化。 请求调页：内存分配（调页操作），延迟至页面访问时刻。一次调入一页。 预调页： 一次调入多个页面。当前需要的页面 + 虚空间中附近的多个页面。 页面置换机制：淘汰暂时不用的页面。将其换至磁盘，释放内存。 基于此技术打造的虚拟存储器，时间 \u0026amp; 空间局部性变现良好的程序，执行速度不会比运行在物理内存慢许多。 虚拟内存器：虚拟存储器用 硬盘中的 swap 分区（或者 swap 文件） 作为主存的辅助存储器，存放所有进程的图像；主存中只存放 CPU 最近需要使用的逻辑页面。\n有了虚拟存储器，只需要装入少量逻辑页面进程就可以运行，访问到其它逻辑页面时，MMU 会抛出异常，缺页异常处理程序调入所缺页面。 虚拟存储器的优点： 启动前不必装入全部进程图像，应用程序装载（exec）速度快 程序员编程不必受物理内存的限制，计算机可以运行虚空间大于内存总容量的应用程序 最后，除非内存抖动，系统不再需要执行 swap in 和 swap out 操作，系统性能提升。 请求调页\n任何应用程序，只需为初始栈分配主存页框，装入 main 函数栈帧后便可以开始运行。其余进程图像，一次一页，访问时，缺页中断处理程序负责调入。\n请求调页是指如果 CPU 访问的数据或指令不在主存，引发缺页异常，异常处理程序调入所缺逻辑页面。\n缺页（Page Fault） CPU 所访问的信息内存中不存在。以 i386 芯片为例，present bit 是 0。缺页异常处理过程：\nMMU 硬件 (1)当前指令执行时操作数不在内存 (2)取指时下条指令不在内存，抛出缺页异常。 随后，CPU 中断处理元件 (1)压栈引发异常的当前指令的地址. (2)cr2 记录引发缺页的那个逻辑地址。 操作系统介入：缺页异常处理程序 (1)找 1 个空闲的 物理页框 (2)修改页表，目标逻辑页对应的 PTE (3)初始化物理页框。从磁盘读入包含 CPU 想要访问的数据或指令的整张逻辑页面（1 张页面，4096 字节，要读 8 个连续磁盘扇区）。 异常返回，进程重新执行引发异常的指令。所缺数据在内存，不会引发缺页异常，程序得以继续运行。 页面置换\n缺页时，异常处理程序会为现运行进程分配一个可用的主存页框。如果内存没了，就要 覆盖一个逻辑页面，用分配给它的物理页框装所缺逻辑页。这个操作就是页面置换。 页面置换方式 固定分配局部置换 为每个进程分配固定数目的物理页框，如果缺页只能覆盖自己的逻辑页面 典型算法：FIFO \\ LRU \\ CLOCK 可变分配局部置换 为每个进程分配一定数目的物理页框，如果缺页，仍然只能覆盖自己的逻辑页面 跟踪进程的执行情况 频繁缺页，为进程追加物理页框 缺页率长期维持较低水平，可以收回部分页框 可变分配全局置换 为每个进程分配一定数目的物理块（物理页框） 系统维护一个空闲物理块队列 当某进程发生缺页时，由系统从 空闲物理块队列 中取出一个分配给该进程 空闲队列分配完时，OS 才会覆盖内存中的逻辑页面 被覆盖的可能是其他进程的逻辑页面，所以叫 全局置换 请求调页系统使用的页表项（PTE）及请求调页操作 例题 页面置换算法（使用固定分配局部置换） 缺页时，若内存已无空闲空间，淘汰一页。用新逻辑页面覆盖被淘汰页面占用的物理页框。若被淘汰页面脏（修改过），写回磁盘。页面置换算法决定淘汰哪一页。优化目标：降低缺页率。\nOPT 未来访问时刻最远的（最优） FIFO 最先进入内存的 LRU 最近最久未访问的 CLOCK（NRU，Not Recently Used）淘汰最近没用过的（不一定是最久） 随机算法 请求调页虚拟存储器相关的理论 工作集和驻留集 抖动 复习重点 # 程序装入内存有几种方式？什么是可重定位的装入技术？ 在动态分区分配中，有那些分区分配算法？各个是如何实现的？ 什么是虚拟存储器？其特征是什么？虚拟存储器容量是如何确定的？ 请求分页技术中，图示 windows 下的两级分页机制？ 请求分页机制中，页面置换算法有那些，具体实施页面置换过程？ 在交换技术中，进程置换策略是什么？ 什么是快表？其中内容是什么样子的？什么是页表？其结构是如何？ 文件系统 # 预读的代码考试不考。知道 read 系统调用什么时候用它就行 到这个程度《文件系统 例题和习题 2 完整的文件读写过程》\nUnix 文件系统 # 文件系统存放很多文件，文件是 可重复访问的字节序列，支持 随机访问、所有字节可 重复读写。 用户存放的文件，是文件系统的用户数据\n可执行文件供进程管理系统使用 普通数据文件供应用程序使用 用来管理文件的数据结构，是文件系统的 元数据（metadata） 每个文件一个文件控制块，登记文件访问权限、文件数据块存放的位置 读写文件，需要使用文件控制块 文件树，挂所有文件，目录搜索就是在文件树上查找文件 用户数据和元数据存放在同一张磁盘 文件基础概念 文件按磁盘数据块大小切块，离散存放在磁盘上，每一块是一个逻辑块 为文件分配的磁盘存储空间，是 整数个 磁盘数据块 文件系统使用 离散存储管理方式。相邻的文件逻辑块在磁盘上 不必连续存放。但尽量连续存放一定能提升文件顺序读写效率。 文件控制块（FCB，File Control Block）\n每个文件有一个文件控制块 FCB，包括如下信息：\n地址映射表，用来计算分配给逻辑块 bn 的物理块号 dn dn = f(bn) /* bn = offset/512; offset是数据在文件中的偏移量 */ 数据存放在物理块 dn，块内偏移量是 offset % 512 文件主 uid，创建该文件的进程的 uid 文件访问权限，登记各类用户对该文件的读、写、执行权限 Unix 是 RWXRWXRWX，标识 文件主，文件所在的用户组 和 nobody 对文件的读、写、执行 权限。 Windows 是 ACL（Access Control List） 进程 uid 和 gid 标识使用文件的用户和用户组 创建时刻，最后一次访问时刻，最后一次修改时刻。 FCB 的使用：\n创建文件时，进程执行系统调用 create(\u0026quot;文件名\u0026quot;, mode) 创建 FCB。mode 是文件的访 问权限 rwxrwxrwx。 新建 FCB，填入文件名，uid=进程 uid，访问权限=mode。文件尺寸=0，创建时刻=time。 访问已有文件，进程需要使用 FCB。 使用文件前，执行 open 系统调用打开文件。 open (\u0026quot;文件名\u0026quot;, mode) 。mode 是进程希望对文件执行的操作：读、写 还是 既读又写。 需要将 FCB 读入内存，使用访问权限字段，判断进程（p_uid 用户）有没有文件的访问权限。 读写文件时，进程执行 read/write 系统调用。 需要使用 FCB 中的地址映射表确定需要读写的磁盘数据块 执行 bread/bwrite/breada……合适的函数，进行字符块读写 文件访问结束，执行 close 系统调用关闭文件。内存中的 FCB，如果发生变化，写回磁盘。 - 写文件会导致文件长度和地址映射表发生变化 文件树，目录项 和 目录文件\n文件树 绝对路径、相对路径 DiskInode DiskInode 是 Unix 的文件控制块。DiskInode 号是文件 ID，文件的内部标识，每个文件，磁盘上有一个 DiskInode。\nclass DiskInode { unsigned int d_mode; // 文件模式 int d_nlink; // 硬链接数 short d_uid; // 文件主的 uid short d_gid; // 文件所在的组 int d_size; // 文件尺寸，字节数 int d_addr[10]; // 混合索引表根节点 int d_atime; // 最后访问时刻 int d_mtime; // 最后修改时刻 }; d_mode，DiskInode 的使用状态、文件类型 和 访问权限 d_addr，用来进行地址映射\n文件卷 每个 文件系统 有自己的 文件卷，存有运行所需的全部内核数据结构和它所管理的数据文件。 卷格式取决于具体的文件系统。Unix 文件卷 和 Windows 文件卷格式完全不同。 超级块，存放文件卷 info 和文件系统的使用状态 inode 区，存放 DiskInode（64 字节）。 空闲标识，d_mode 中 IALLOC 为 0，不在内存打开 inode 池中 DiskInode 编号由存储位置决定，n# DiskInode，扇区号 n/8+2，扇区内偏移量 n%8 数据区，存放普通数据文件和目录文件（数据块、索引块）。数据区的资源是物理块，Unix V6 中为 1 个扇区、512 字节没有空闲标识 Unix V6++系统中文件\n磁盘上的普通数据文件 混合索引树 DiskInode 中的 d_addr 数组是混合索引树的根节点。 d_addr [0] ~ d_addr [5]，可以登记 6 个物理块号，存放文件的 0#~5#逻辑块。 d_addr [6]，第 1 个索引块，可以登记 128 个物理块号。 d_addr [7]，第 2 个索引盘块，可以登记 128 个物理块号。 d_addr [8] 和 d_addr [9] 是 2 次索引块。每个 2 次索引盘块可以挂 128 个一次索引盘块，用来支持很大的文件。 磁盘上的目录文件 John 的目录项，存放在目录文件 home 特殊文件（外设硬件）\n磁盘空闲资源管理 主硬盘 文件系统的使用 # 文件系统的使用过程 使用前装载 mount 将超级块读入内存。分配、释放存储资源需要使用空闲盘块号栈和空闲 Inode 栈。 将根目录 Inode 读入内存。搜索文件时要用文件树。 使用阶段 搜索、维护文件树 （1）打开已有文件、目录 （2）新建文件/子目录时，增加节点和边 （3）删除文件/子目录时，去除节点和边。 访问普通数据文件。read、write 系统调用。写文件会更新 DiskInode。 使用完毕卸载 unmount 超级块 和 所有脏数据写回磁盘 文件系统的元数据 metadata 文件系统的元数据 metadata 是文件系统持久化在磁盘上的内核数据结构 Unix V6++：超级块、DiskInode 和 DirectoryEntry 磁盘上的数据结构，使用前，复制进内存。用完，更新后的数据结构写回磁盘。 支持文件系统运行的数据结构（系统层面） 文件系统会话 支持文件系统运行的数据结构（进程层面） 外部标识：文件路径名； 内部标识：文件描述符，打开文件表的下标 fd 进程访问数据文件，需要使用打开文件结构 read 系统调用 write 系统调用 seek 系统调用 文件树使用和维护 打开文件结构的使用和维护 fd=open() 建立打开文件结构 close(fd) 拆除打开文件结构，释放资源 fork 创建的子进程集成父进程打开的文件 进程的标准输入、输出文件 这三个文件无需打开。它们，用户登录（login）时打开，fork 时继承自 shell 进程（V6++没有登录过程，系统初始化时 main0 打开这 3 个文件）所以进程打开文件表中 0,1,2 项要空出来，从 3 开始分配 File 结构。 0，STDIN, 标准输入 1，STDOUT，标准输出 2，STDERR，标准错误输出(Unix V6++没有) 标准输入输出文件的使用 复习重点 # 什么是文件？什么是文件系统？文件系统设计目标是什么？ 什么是文件的逻辑结构、物理结构？文件物理结构有哪些？分别如何实现？有什么特点？ UNIX 系统采用的综合索引方式是如何实现的？有何优点？ 磁盘空闲空间的管理方法？图示成组链接法？并说明其优点。 什么是目录文件的组成？采用目标文件的目的？目录的改进方法及其改进性能比较？常用的目录结构？ RAID 的概念？关键技术是什么？ 文件操作中, open 函数实现过程及其完成的内容？ 影响磁盘访问的因素有那些？列举几种磁盘调度算法？ The End.\n","date":"2024-12-29","externalUrl":null,"permalink":"/docs/os/","section":"文档","summary":"\u003ch1 class=\"relative group\"\u003e2024 操作系统期末复习 \n    \u003cdiv id=\"2024-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#2024-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTongji University. 2024/12/28\u003c/p\u003e\n\u003cp\u003eAuthor: Hyoung Yan\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e本文框架 \n    \u003cdiv id=\"%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"image/2024%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB/1735405694119.png\" alt=\"1735405694119\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"2024 操作系统期末复习","type":"docs"},{"content":"","date":"2024-12-29","externalUrl":null,"permalink":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"操作系统","type":"tags"},{"content":"","date":"2024-12-29","externalUrl":null,"permalink":"/tags/%E5%A4%8D%E4%B9%A0/","section":"Tags","summary":"","title":"复习","type":"tags"},{"content":" 2024 计算机系统结构复习 # Tongji University. 2024/12/24\nAuthor: Hyoung Yan\n本文框架 # 本文按照 2024 计算机系统结构考纲整理。 考试题型：\n单项选择题（每题 2 分，共 26 分） 填空题（每空 1 分，共 14 分） 大题（6 题，共 60 分） 大题的复习范围 # 会利用 CPU 性能公式比较多种设计方案的优劣，尤其是 CPI 的计算 CPU 性能公式\n公式一 $$CPU时间=一个程序的CPU时钟周期数 \\times 时钟周期长度$$ 公式二 $$CPU时间=指令数 \\times CPI \\times 时钟周期长度$$ 公式三 $$CPU时间=(\\sum_{i=1}^{n} CPI_i \\times IC_i)\\times 时钟周期长度$$ 推导出 CPI 的公式： $$CPI=\\frac{CPU时钟周期数}{指令数}=\\frac{\\sum_{i=1}^{n} (CPI_i \\times IC_i)}{IC}=\\sum_{i=1}^{n}(CPI_i \\times \\frac{IC_i}{IC})$$ Amdahl 定律计算加速比 Amdahl 定律：计算机系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种执行方式的使用频率火占总执行时间的比例有关。 $$S_n=\\frac{T_0}{T_n}=\\frac{1}{(1-F_e)+\\frac{F_e}{S_e}}$$\nSn: 整个系统的加速比\nT0: 系统在原有执行方式下的执行时间\nTn: 系统在新的执行方式下的执行时间\nFe: 增强比例（改进部分占整个任务的时间比例）\nFe=可改进部分占用的时间/改进前整个任务的执行时间\nSe: 增强加速比（改进部分的加速比）\nSe=改进前改进部分的执行时间/改进后改进部分的执行时间\n指令系统设计：设计操作码（3 种方法都要）、设计指令字（操作码+若干地址码）格式 操作码的评价方法\n平均码长：\\( p_i \\)频率，\\( l_i \\)编码长度 $$L=\\sum_{i=1}^{n} p_i \\times l_i$$ 信息冗余量： $$R=1-\\frac{H}{l}$$ 信息熵： $$H=-\\sum_{i=1}^{n} p_i \\times \\log_2 p_i$$ 操作码的优化设计\n固定长度操作码：所有指令的操作码长度都是相同的。如果需要编码的指令有 n 条，则固定长度操作码的位数至少需要 \\(log_2n\\) 位。目前许多的 RISC 采用该思想。\n优点：非常规整，硬件译码简单 缺点：操作码长度过长，浪费存储空间 Huffman 编码： 概率高的用短位数表示，概率低的用长位数表示。.\n特点：是最优化的编码方式（平均码长最短，信息的冗余量最小），但操作码很不规整。 扩展编码法：是固定长度操作码和 Huffman 编码法相结合形成的。即：先根据指令使用频率的宏观分布，将指令分成有限几类；然后根据 Huffman 编码原理，对使用频率高的指令类采用短位数，使用频率低的指令类采用长位数；同一类指令内采用固定长度操作码。\n等长扩展编码法：每类指令的操作码长度相同 等长（4-8-12）15/15/15 等长（4-8-12）8/64/512 不等长扩展编码法：每类指令的操作码长度不同 指令字设计优化\n问题：操作码和地址码的优化，会造成指令字的不定长，无法同时满足速度快和空间省。可以合理结合，形成定长或多种长度的指令字，例如长操作码+短地址码。\n变长编码格式：寻址方式通过设置专门的地址描述符给出，因为指令有多个操作数，无法在操作码中进行编码。\n定长编码格式：将操作类型和寻址方式一起编码到操作码中。当寻址方式和操作类型非常少时，这种编码格式非常好。可以有效降低译码的复杂度。 混合型编码格式：提供若干种固定的指令字长。以期达到既能够减少目标代码长度又能降低译码复杂度的目标。 Cache 存储系统的性能分析，重点是 AMAT\nCPU 执行时间 平均存储器访问时间（AMAT） Cache 缺失率与块大小之间的关系，会计算最佳块大小\n增加块大小会先降低后增加缺失率：增加块大小会降低强制缺失率，这是利用了空间局部性原理。但因为它减少了 Cache 中的块数，加重了冲突缺失，如果 Cache 容量较小时，甚至会有容量缺失。 增加块大小会增加缺失代价 块大小的选择取决于较低层存储器的延迟和带宽。 低延迟和高带宽存储器使得块大小要大些，因为这样在每次缺失时 Cache 可以获得更多的字节，而缺失代价只有少量的增加； 相反，高延迟和低带宽存储器希望块大小要小些，因为较大的块并不能节省多少时间。 最佳块大小：使缺失率和缺失代价的乘积最小 掌握提高 Cache 存储系统性能的途径及具体方法，每种方法只需了解原理即可 根据 AMAT 公式可以看出，提高 Cache 性能的途径有： 降低缺失代价 多级 Cache 请求字处理技术：尽早重启动，请求字优先 让读缺失优先于写 合并写缓冲区 牺牲者 Cache 降低缺失率 增加 Cache 块大小 增加 Cache 容量 增加相联度 路预测和伪相联 Cache 编译优化 通过并行性降低缺失代价/缺失率 非阻塞 Cache 技术 指令和数据硬件预取 编译控制的预取 降低 Cache 命中时间 小而简单的 Cache 虚拟 Cache 流水 Cache 存取 跟踪 Cache 流水线的性能分析，要求会根据具体流水线进行计算，重点掌握消除瓶颈功能段的方法\n吞吐率：单位时间内流水线所能流出的任务数或能流出的结果数。 各段时间相等 各段时间不等 加速比：完成同样一批任务，不使用流水线完成所用的时间与使用流水线完成所用的时间之比。 各段时间相等 各段时间不等 效率：是指流水线的设备利用率。在时空图上，流水线的效率定义为 n 个任务占用的时空区与 m 个功能段总的时空区之比。 各段时间相等 各段时间不等 流水线最佳段数的选择：从性价比角度出发流水线存在着最佳段数。 流水线瓶颈： 流水线的 TP 和 TPmax 主要由流水线中执行时间最长的那个功能段来决定，这个功能段就成了整个流水线的“瓶颈”。\n将流水线中的瓶颈再细分； 通过重复设置多套瓶颈功能段，让多个瓶颈功能段并行工作。 流水线中相关性分析，会分析数据相关（3 种）和控制相关，并掌握它们的解决方法 相关（Correlation or Dependency）也称为冲突（Hazard）是指邻近指令之间存在着某种关系，影响指令的重叠执行或流水线的正常运行。\n资源相关：争用部件 数据相关：改变操作数的读写顺序，使得顺序执行与流水执行时结果不同。 “先写后读”相关在流水线顺序执行和乱序执行时都可能发生，“先读后写”相关和“写写”相关只有在流水线乱序执行时才可能发生，而“读读”相关无需处理。\n数据相关类型：\n先写后读相关（RAW） 先读后写相关（WAR） 写写相关（WW） 解决方法 控制相关：分支、转子程序、中断 因程序的执行方向可能被改变而引起的相关，也称为全局相关（而将前面介绍的其他相关称为局部相关）。可能改变程序执行方向的指令主要包括：无条件转移、条件转移、子程序调用、中断等。\n条件转移的处理：\n条件出来前：提前形成条件码，预测 条件出来后：停顿 中断的处理：\n不精确断点 精确断点 超长指令字处理机的工作原理，会结合循环展开进行指令调度\n在编译时，编译程序找出指令间潜在的并行性，将多个能并行执行的不相关或无关的操作先行压缩组合在一起，形成一条有多个操作段的超长指令； 运行时，不再用软件/硬件来检测其并行性，直接由这条超长指令控制机器中多个相互独立的功能部件并行操作。 每个操作段控制其中的一个功能部件，相当于同时执行多条指令。 超标量流水线的工作原理，会进行调度 超标量处理机必须有两条或两条以上能够同时工作的指令流水线，采用多发射方式：\n每个周期同时取多条指令、同时译码多条指令、同时执行多条指令、同时写回多个运算结果。 需要多个取指令部件、多个指令译码部件和多个写结果部件，设置多个指令执行部件，复杂的指令执行部件一般采用流水线结构。 设计目标是每个时钟周期平均执行多条指令，ILP 的期望值大于 1。 调度方法\n顺序发射顺序完成 顺序发射乱序完成 乱序发射乱序完成 向量处理机中的向量链接技术，会计算整个向量程序的执行时间 对于有写读数据相关的向量指令，可以采用“相关专用通道”：从一个流水线部件得到的结果直接送入另一个流水线部件的操作数寄存器，这样多条向量指令可以并行执行，这种技术称为流水线的链接技术。 多级互连网络的设计，需掌握其基本原理方可进行设计 多级互连网络用若干个较小规模的开关模块组成开关级，开关级之间有固定连接的级间连接，通过控制信号改变开关模块的输入端与输出端之间的连接状态，从而可改变网络输入端与输出端之间的连接。 阻塞型网络（阻塞原因的分析）和全排列网络（实现方法） 在同时实现两对或多对入端和出端之间的连接时，有可能因争用数据传送通路而发生冲突的网络称为阻塞型网络。反之，将能够实现所有可能的入、出端间的连接而不发生冲突的互连网络称为非阻塞型网络或全排列网络。 例如：在 Omega 网络中，如果同时进行 5→0（JGA=101）和 7→1（LGA=110）连接时，产生冲突，不能同时进行（见后图）；则 Omega 网络就是阻塞型网络。\n阻塞原因： 全排列网络的实现\n多次经过同一多级网络：将这种只要经过重新排列已有入出端对的连接，就可以完成所有可能的入出端间的连接而不发生冲突的互连网络称为可重排列网络。 多个多级网络串联使用：例如：将多级立方体网络和它的逆网络连在一起，省去中间重复的一级后，构成的全排列网络称为 Benes 网络。 Omega 网络：会画出其拓扑结构 Omega 网络：采用 \\( 2 \\times 2 \\) 的四功能开关，对于 \\( N \\times N \\) 网络，有 \\( n = \\log_2 N \\) 个开关级，每级有 \\( N / 2 \\) 个开关； \\( n \\) 个开关级从输入端到输出端依次为 \\( K_{n-1}, \\dots, K_1, K_0 \\)，\\( n+1 \\) 个级间连接依次为 \\( C_n, \\dots, C_1, C_0 \\)，\n其中 \\( C_0 \\) 为恒等置换，\\( C_1 \\sim C_n \\) 都为均匀洗牌置换；开关采用单元控制方式。 本网络也称为：多级洗牌置换网络或多级混洗网络。 其他题的复习范围 # 计算机系统层次结构：分层的思想 分层的目的：\n有利于正确地理解计算机系统的工作，明确软件、硬件和固件在计算机系统中的地位和作用； 有利于理解各种语言的实质及其实现； 有利于探索虚拟机器新的实现方法，设计新的计算机系统。 衡量机器性能的唯一固定而且可靠的标准是什么？ 真正执行程序的时间 常用的基准测试程序有哪些？ 主要有 5 类测试程序（以测量准确程度递减的次序排列）：\n真实程序 改造/模拟程序 核心测试程序 小测试程序 合成测试程序 基准测试程序套件：把应用程序中用得最频繁的那部分核心程序作为评价计算机性能的标准程序（benchmark）。\n桌面机 benchmarks：SPEC CPU，SPECviewperf 服务器 benchmarks：SPEC CPU，TPC 嵌入式 benchmarks：EEMBC 并行性的常用实现技术，并结合本课程的内容进行举例\n时间重叠：让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而提高效率。 指令流水线 资源重复：通过重复设置资源（硬件、软件、信息、时间）来提高可靠性或性能。 N 模冗余结构（提高可靠性）、多值存储器（提高信息存储密度）、多处理机（提高速度和可靠性） 资源共享：利用软件的方法让多个用户按一定的时间顺序轮流地使用同一套资源，以提高资源利用率，从而提高整个系统的功能。 多道程序分时系统 设计计算机系统的常用定量准则\n加快经常性事件的速度：使用 Amdahl 定律 CPU 性能公式：通过公式计算和比较不同设计方案的性能 局部性原理：程序执行中频繁重复使用最近已使用过的数据和指令，分为时间局部性和空间局部性 利用并行性：通过并行处理提高系统性能 Flynn 分类法 指令流是机器执行的指令序列，数据流是指令所操作的数据序列。 Flynn 分类法是根据指令流和数据流的多倍性来划分的，分为四类：\nSISD：单指令流单数据流 SIMD：单指令流多数据流 MISD：多指令流单数据流 MIMD：多指令流多数据流 什么是数据表示？什么是数据结构？\n数据类型：计算机系统中可以使用和处理的各种数据的类型，主要有：整数、布尔数、字符、文件、图、表、树、阵列、队列、链表、栈、向量、串等； 数据表示：能由硬件直接识别和引用（即有相应运算指令和有硬件支持）的数据类型，例如：定点数据表示、逻辑数据表示、浮点数据表示等。数据表示是数据类型中最常用、也是相对较简单，用硬件实现相对比较容易的； 数据结构：带有结构的数据元素的集合，例如：串、队列、栈、向量、阵列、链表、树、图等。数据结构由软件进行实现，转换成数据表示。 RISC 的思想、特点和常用技术，重点掌握重叠寄存器窗口技术 RISC 的思想：减少指令总数和简化指令的功能来降低硬件设计的复杂度，提高指令的执行速度。\nRISC 的特点：指令集简单，硬件实现容易\nRISC 的关键技术：\n硬件为主固件为辅 在 CPU 中设置数量较大的寄存器组：采用重叠寄存器窗口技术提高使用效率 指令的执行采用流水：采用延时转移技术和指令取消技术来降低（条件）转移指令的影响 采用认真设计和优化编译系统设计的技术：例如指令流调整技术 重叠寄存器窗口技术：将设置的大量寄存器，分为多个组和一个全局区；每组中分高、本、低三个区；相邻组的高、低区重叠；不同的过程使用不同的组和共享全局区，这样可以加速参数与结果的传递。\n常用 Cache 的替换算法的硬件实现，重点掌握比较对法，以及如何降低成本 为什么需要 Cache 替换算法？：当发生块失效，且可以装入新调入块的几个 Cache 块都已经被装满时，此时需要 Cache 替换算法。直接映象方式实际上不需要替换算法，而全相联映象方式的替换算法最复杂。Cache 替换算法全部用硬件实现。\n轮换法： 本质上是一种FIFO 算法，通常用于组相联映像和地址变换方式中，常见的实现有：\n每块一个计数器 装入或替换时，被装入或替换的块计数器置 0，同组其他块的计数器加 1； 命中时，块计数器不变 需要替换时，替换计数器最大的块。 每组一个计数器：本组有替换时，计数器加 1，计数器的值就是要被替换出去的块号。 LRU 算法： 在块表中为 Cache 的每块都设置一个替换计数器，长度与“组内块号”字段相同。\n装入或替换时，被装入或替换的块计数器置 0，同组其他块计数器加 1； 命中时，命中块计数器置 0，同组中比他置 0 前的值小的计数器加 1，其他不变； 需替换时，同组中计数器值最大（一般为全 1）的块被替换。 堆栈法： 堆栈法本质上是一种 LRU 算法，用栈顶到栈底的先后次序来记录 Cache 同一组内的各个块被访问的先后次序，栈顶是最近被访问过的块，栈底是最久没有被访问过的块。 比较对法： 比较对法本质上是一种 LRU 算法，采用硬联逻辑实现。 一个两态的器件（触发器）能够记录两个块之间的先后顺序，多个块之间的先后顺序可以用多个两态器件的组合来实现，从而可以在多个块中找出最久没有被访问过的那个块。 导致缺失的原因分析\n强制缺失(Compulsory)：对第一个块的第一次访问一定不在 Cache 中，所以该块必须被调入到 Cache 中。也叫作冷启动缺失，首次访问缺失。 容量缺失:(Capacity)：如果 Cache 容纳不了一个程序持续执行所需要的所有块，当某些块被替换后，若又重新被访问就会发生缺失。 冲突缺失:(Confict)：如果采用组相联/直接相联，若太多的块映射到同一组(块)中，则会出现该组中某块被别的块替换后又被重新访问，这就发生冲突缺失。 规律\n相联度越高，冲突缺失越少 强制缺失和容量缺失不受相联度影响 强制缺失不受 Cache 大小影响，但容量缺失却随着容量的增加而减少 减少三种缺失的方法\n强制缺失（本身很少）：增加块大小，预取 容量缺失：增加容量 冲突缺失：增加相联度（理想情况下全相联） 许多降低缺失率的方法会增加命中时间或缺失代价\n多级 Cache 中的局部缺失率和全局缺失率，会进行计算\n局部缺失率 本级 Cache 的缺失数除以对本级 Cache 的存储器访问总数。例如：第一级 Cache 的局部缺失率为\\(缺失率_{L1}\\)，第二级 Cache 的局部缺失率为\\(缺失率_{L2}\\) 全局缺失率 本级 Cache 的缺失数除以 CPU 产生的存储器访问总数。例如：第一级 Cache 的全局缺失率为\\( 缺失率_{L1} \\)，第二级 Cache 的全局缺失率为 \\(缺失率_{L1} \\times 缺失率_{L2} \\) 流水线的特点、常用分类 流水线的特点\n空间并行性、时间并行性 只有连续提供同类任务才能发挥流水线的效率。 尽量减少因条件分支而造成的断流，可以通过编译技术提供连续的相同类型操作 每个流水线段都要设置一个流水寄存器。 用于保存本流水线段的执行结果，会使流水线的执行时机加长，是流水线中需要增加的主要硬件 各流水线段的时间应该尽量相等。 流水线处理机的基本始终周期等于时间最长的流水段的时间长度 流水线需要有装入时间和排空时间 流水线的分类\n单功能流水线 | 多功能流水线\n多功能流水线细分：\n静态流水线 | 动态流水线 （同一时间内连接成多种方式、同时执行多种功能） 线性流水线 | 非线性流水线 （各个功能段间是否有反馈信号） 部件级流水线 | 处理机级流水线 | 系统级流水线 标量流水线 | 向量流水线 顺序流水线 | 异步流水线 常见的数据相关有哪些？通常在哪些流水线上会出现？\n先写后读相关 RAW ：写读相关，正相关，数据相关。在流水线顺序执行和乱序执行时都可能发生 先读后写相关 WAR ：读写相关，反相关。在流水线乱序执行时可能发生 先写后读相关 WAW ：输出相关。在流水线乱序执行时可能发生 读读相关不需要处理 数据相关的解决方法\n先写后读相关 RAW：设置专用路径、退后处理、指令调度 先读后写相关 WAR 和写写相关 WW：寄存器换名 对条件转移指令指令引起的全局相关通常是如何处理的？\n条件出来前：提前形成条件码，预测 条件出来后：停顿 动态预测技术有哪四个？基本思想是什么？ 动态预测技术 基本思想 转移预测缓冲器 依赖本条件转移指令的历史信息（局部） 相关转移预测器 依赖于已经发生过的其他条件转移指令的历史信息（全局） 自适应预测器 设置两个预测器，一个基于局部信息，另一个基于全局信息，并使用一个选择器组合，根据指令选择合适的预测器 分支目标预测器 BTB 采用一个小容量的高速缓冲器保存最近转移成功的 k 条转移指令的指令地址和分支目标地址 相关转移预测器：思想、实现，会计算所需容量，特别（2，2）相关转移预测器 思想：依靠已经发生过的其他条件转移指令的历史信息（全局信息）来预测当前的条件转移指令的转移方向，可以提高预测的准确性。 Num of bits in an (m,n) predictor: \\(2^m \\times n \\times N\\),\nN:number of prediction entries selected by the branch address.\n(2,2) predictor Tomasulo 算法和前瞻执行机制中的换名功能分别是如何实现的？ Tomasulo 算法的寄存器换名是通过保留站实现的 前瞻执行机制是通过 ROB 缓冲器实现的 指令流水线对循环进行优化技术有哪些？它们的原理是什么？\n调度技术 循环展开：多次复制循环体代码，并调整循环出口代码。 循环展开通常展开成一对循环：设循环次数为 n，每次展开 k 次。 第一个循环：循环体与原来一样，循环次数为：n mod k。 第二个循环：循环体是原来循环体展开 k 次而得，循环次数为：n/k。 软件流水：软件流水是一种重组循环的技术，如果循环体间是相互独立的，可以将来自不同循环体间的指令（循环控制指令除外）组成一个新循环体，在保证循环体中的相关关系的同时提高并行性。 多发射处理机主要有哪些？它们的工作原理是什么？\n超标量流水处理机 超长指令字处理机 比较：\n超标量处理机通过重复设置硬件来提高性能（空间并行性） 超流水线处理机只需要增加少量硬件，通过各部分硬件的充分重叠工作来提高性能（时间并行性） 向量处理机的常见的相关和冲突有哪些？ 向量链接技术：会判断是否可以采用本技术，并计算执行时间 向量链接技术：对于有写读数据香港的向量指令，可采用相关专用通道，从一个流水线部件得到的结果直接送入另一个流水线部件的操作数寄存器中。\n没有向量寄存器冲突和运算部件冲突； 只有当前一条指令的第一个结果分量送入结果向量寄存器的那一个时钟周期方可链接，否则只能串行执行； 若一条向量指令的两个源操作数分别是两条先行指令的结果时，要求： 先行的两条指令产生结果的时间必须相等； 先行的两条指令的向量长度必须相等。 要进行链接执行的向量指令的向量长度必须相等，否则无法进行链接。 评价向量处理机性能的参数有哪些（会进行计算，尤其第一个参数）？及其具体用途是什么？\n向量指令处理时间\n一条向量指令的处理时间： $$T_{\\text{vp}}=T_s+T_{vf}+(n-1)T_c$$ $$T_{vp}=(T_{start}+n)T_c$$\n\\(T_s\\)：向量指令的建立时间 \\( T_{vf} \\)：向量指令的流过时间 \\(T_c\\)：时钟周期时间 \\(n\\)：向量长度 \\(T_{start}\\)：向量指令的启动时间 一批向量指令的处理时间： 向量长度\u0026lt;=向量寄存器长度时，向量指令的处理时间： $$T_{\\text{all}}=(T_{start}+mn)T_c$$ \\(m\\)：编队数 \\(n\\)：向量长度 向量长度\u0026gt;向量寄存器长度时，向量指令的处理时间： $$T_{\\text{all}}=(T_{start}+mN_{\\text{v}})T_c$$ 分段开采，向量长度为 n 的一组向量操作执行时间: $$T_n=\\left\\lceil \\frac{n}{\\text{MVL}} \\right\\rceil \\times (T_{loop}+T_{start})+n \\times T_{chine}$$ \\(T_{loop}\\)：标量代码开销 \\(T_{chine}\\)：编队数 \\(T_{start}\\)：所有编队向量指令的启动时间 最大性能\\(P_{\\infty}\\) 半性能向量长度\\(N_{\\frac{1}{2}}\\)\n为达到一半 \\( R_{\\infty} \\) 值所需的向量长度称为半性能向量长度 \\(n_{\\frac{1}{2}}\\)，主要评价向量流水线建立时间对性能的影响。 向量长度临界值\\(N_{\\text{v}}\\)\n\\(n_v\\)表示向量流水方式的工作速度优于标量串行方式工作时所需得向量长度临界值。该参数既衡量建立时间，也衡量标量/向量速度比对性能的影响。\n常用的互连函数\n恒等置换 交换置换 方体置换 均匀洗牌置换 均匀洗牌与逆均匀洗牌是两个十分有用的互连函数，以它们代表的链路与以交换置换代表的开关多级组合起来可构成 Omega（Ω）网络与逆 Omega（Ω）网络。σ 函数在实现多项式求值、矩阵转置和 FFT 等并行运算以及并行排序等方面都得到广泛的应用。 蝶式置换 位序颠倒置换 移数置换 加减\\(2^i\\)置换 常用的静态互连网络有哪些，它们的结构参数，重点掌握对称性 ILLIAC-IV 阵列处理机所用的互连函数 Delta 网：思想，会计算减少的开关数 交叉开关网络： Delta 网： 用\\(a \\times b\\)的交叉开关模块构成\\(a^n \\times b^n\\)的交叉开关网络，其中指数\\(n\\)为互连网络的级数。 例如：用4×4的交叉开关模块构成42×42的交叉开关网络，其中指数2为互连网络的级数。 Omega 网络的结构和特点 Omega 网络：采用 \\( 2 \\times 2 \\) 的四功能开关，对于 \\( N \\times N \\) 网络，有 \\( n = \\log_2 N \\) 个开关级，每级有 \\( N / 2 \\) 个开关； \\( n \\) 个开关级从输入端到输出端依次为 \\( K_{n-1}, \\dots, K_1, K_0 \\)，\\( n+1 \\) 个级间连接依次为 \\( C_n, \\dots, C_1, C_0 \\)，\n其中 \\( C_0 \\) 为恒等置换，\\( C_1 \\sim C_n \\) 都为均匀洗牌置换；开关采用单元控制方式。 本网络也称为：多级洗牌置换网络或多级混洗网络。 互连网络中常见的消息寻径方式有哪些？重点掌握虫蚀寻径\n线路交换寻径： 方法：先建立一条从源节点到目的节点的物理通路，然后再传递消息。 优点：传输带宽较大，平均传输时延较小，使用缓冲区少。适合于具有动态和突发性的大规模并行处理数据的传送。 缺点：建立源节点到目的节点的物理通路开销很大，占用物理通路的时间长。 传输时延：$$T_{CS}=(L_t/B)\\times(D+1)+L/B$$ 其中,Lt 为建立路径所需小信息包的长度；L 为信息包的长度；D 为经过的中间节点数；B 为带宽。 存储转发寻径： 方法：信息流的基本单位是包，每个节点有一个包缓冲区，包从源节点经过中间节点（存储 - 转发）到达目的节点。 优点：占用物理通路的时间比较短。 缺点：包缓冲区大（不利于 VLSI 实现），时延大（与节点距离成正比）。 传输时延：$$T_{SF}=(L/B)\\times(D+1)$$ 其中，L 为信息包的长度；D 为经过的中间节点数；B 为带宽。 虚拟直通寻径： 方法：当接收到用作寻径的包头部时，即开始路由选择，这样可以降低时延。（是对存储转发寻径的改进） 优点：通信时延与节点数无关。最佳情况下的通信时延同“线路交换寻径”（整条链路都空闲时）。 缺点：出现寻径阻塞时只能将整个包存储在寻径节点中，故节点皆需足够大的缓冲区来存储最大包。最坏情况下的通信时延同“存储转发寻径”，此时经过的每个节点都发生阻塞，都需缓冲。 传输时延：$$T_{VCT}=(L_h/B)\\times D + L/B$$ 其中，Lh 为包寻径头部的长度； L 为信息包的长度；D 为经过的中间节点数；B 为带宽。一般有：L\u0026gt;\u0026gt;Lh×D，通信时延可以近似为：TVCT ＝ L/B，与节点数无关。 虫蚀寻径： 将包分成更小的片，在每个节点的寻径器中设置片缓冲区。用头片直接开辟一条从输入节点到输出节点的路径，每个包中的片以流水方式在网络中向前“蠕动”（是对虚拟直通寻径的改进）。 当包的头片到达一个节点 A 的寻径器后，寻径器根据头片的寻径消息立即做出路由选择。如果所选择的通道或节点的片缓冲区不可用时，头片必须在该节点的片缓冲区中等待，其它数据片也在原来的节点上等待。 传输时延：$$T_{WH}=(L_f/B)\\times D+L/B$$ 其中，Lf 为片的长度； L 为信息包的长度；D 为经过的节点数；B 为带宽。一般有：L\u0026gt;\u0026gt;Lf×D，通信时延可以近似为：TWH＝L/B，与节点数无关。 优点：每个节点的缓冲区较小；较低的网络传输时延，采用了时间并行性；通道共享性好，利用率高；易于实现选播和广播通信方式。 缺点：当包的一个片被阻塞时，整个包都被阻塞在所有节点，占用了节点资源。 互连网络中常见的消息寻径算法有哪些？重点掌握 E 立方体寻径 寻径算法的目的是找出一条从源节点到目的节点的路径以便传送消息。寻径算法可分为两大类（都需要无死锁算法）\n确定寻径算法：寻找的路径是预先唯一确定额的，完全根据源和目的地址确定，与网络的状况无关。 自适应寻径算法：寻找的路径可能会有多条，取决于网络的状况。可采用虚拟通道避免死锁。 确定寻径算法-维序寻径\n维序寻径在二维网格网络中称为 X-Y 寻径，在三维网格网络中称为 X-Y-Z 寻径 维序寻径在超立方体（n 维立方体）网络中称为 E 立方体寻径（E-cube routing） 寻径是按照维的顺序进行的（维 1→ 维 2 → … → 维 n ） 如果源节点和目的节点二进制编号的第 i 位相同，则沿维 i 方向不需要寻径 否则从当前节点沿着这一维方向走到其他节点 重复此过程直至到达目的节点 The End.\n","date":"2024-12-25","externalUrl":null,"permalink":"/docs/systemstructure/","section":"文档","summary":"\u003ch1 class=\"relative group\"\u003e2024 计算机系统结构复习 \n    \u003cdiv id=\"2024-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#2024-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTongji University. 2024/12/24\u003c/p\u003e\n\u003cp\u003eAuthor: Hyoung Yan\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e本文框架 \n    \u003cdiv id=\"%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e本文按照 2024 计算机系统结构考纲整理。\u003c/strong\u003e\n\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"2024%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%A1%86%E6%9E%B6.png\" alt=\"本文框架\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"2024 计算机系统结构复习","type":"docs"},{"content":"","date":"2024-12-25","externalUrl":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"计算机系统结构","type":"tags"},{"content":" 2024 软件工程复习 # Tongji University. 2024/12/21 Hyoung Yan\n本文框架 # Chapter 1: 软件工程概述 # 背景知识 # 软件是计算机系统中与硬件相互依存的另一部分，它是包括程序、数据及其相关文档组成的完整集合。 软件是一种逻辑实体，具有抽象性。软件具有 复杂度、一致性、可变性和无不可见性 等固有的内在特性，这是造成软件开发困难的根本原因。\n软件 = 程序+数据+文档 程序：程序是按照事先设计好的功能和性能要求执行的指令序列 数据：数据是指程序等正常处理信息的数据和数据结构 文档：文档是与软件开发、设计、运行、维护有关的图文资料 软件分类 可按照用途分类，也可根据软件的规模、软件的工作方式、使用频度、失效后的影响等进行分类。\n系统软件：系统软件是为其他软件服务的软件 实时软件：管理、分析、控制现实世界所发生的事件的软件 商业管理软件：商业信息处理是最大的软件应用领域，各类管理信息系统(MIS)、企业资源计划(ERP)、客户关系管理(CRM)等都是典型的商业管理软件 工程与科学计算软件：此类软件的特征是要实现特定的“数值分析”算法 嵌入式软件：嵌入式软件是指嵌入在各种电子设备中的软件，完成很有限、很专业的功能的软件 人工智能软件：利用非数值算法去解决复杂问题的软件。各类专家系统、模式识别软件、人工神经网络软件都属于人工智能软件。 个人计算机软件：文字处理系统、电子表格、游戏娱乐软件等 软件危机：是指在计算机软件的开发和维护过程中所遇到的一系列严重问题\n其一，如何开发软件，以满足不断增长、日趋复杂的需求 其二，如何维护数量不断膨胀的软件产品 软件开发问题的解决途径 1968 年北大西洋公约组织（NATO）召开国际会议，提出“软件工程”概念和术语。 软件工程概述 # 系统的特征\n系统是相互联系的一组元素的集合 系统是具有特点功能的有机整体 系统是有边界的 系统需要和其他系统交互 一个系统可能包含另一个系统 系统是逐渐演变形成的 工程的概念 工程的方法： 工程是将理论与所学的知识应用于实践的科学，以便经济有效地解决实际问题。\n工程的特征：\n注重系统的构建过程 平衡与决策 度量与验证 训练有素的过程 团队协作与角色分工 系统地运用工具 工程原则、标准和实践 重用设计和设计制品 什么是软件工程？ 软件工程是：\n将系统性的、规范化的、可定量的方法应用于软件的开发、运行和维护，即工程化应用到软件上 对 1 中所述方法的研究 软件工程的基本目标\n较低的开发成本 按时完成开发任务并及时交付 实现客户要求的功能 所开发软件具有良好的性能 较高的可靠性、可扩展性、可移植性 软件维护费用低 软件质量属性\n什么是好的软件？ 功能质量、结构质量、过程质量 McCall 质量模型 ISO9126 质量模型 软件过程模型 # 软件开发活动\n问题定义：人们通过开展技术探索和市场调查等活动，研究系统的可行性和可能解决方案，确定待开发系统的总体目标和范围 需求开发：在可行性研究之后，分析、整理和提炼所收集到的客户需求，建立完整的需求分析模型，编写软件需求规格说明 软件设计：根据需求规格说明，确定软件体系结构，进一步设计每个系统部件的实现算法、数据结构及其接口等 软件实现：概括说是将软件设计转换为程序代码，是一个复杂且迭代的过程，要求根据设计模型进行程序设计以及正确高效地编写和测试代码 软件测试：检查和验证所开发的系统是否符合用户期望，包括单元测试、子系统测试、集成测试和验收测试等 软件演化：系统投入使用后对其进行改进，以适应不断变化的需求，将系统的开发和维护看作一个连续的过程更有意义。 瀑布模型：瀑布模型的开发阶段严格按照线性方式进行，每一个阶段具有相关的里程碑和交付产品，且需要确认和验收。\n需求定义与分析 软件设计 软件实现 软件测试 软件运行与维护 讨论： 瀑布模型是否反映了实际的软件开发过程？软件开发作为一个问题求解过程，应当具备什么特点？\n瀑布模型源于硬件领域，它从制造业的角度来审视软件开发。制造业是通过批量生产某一特定产品来实现的，而软件开发则不同。随着人们对问题的深入理解以及对可选方案的不断评估，软件在开发过程中不断演化。因此，软件开发更像是一个创造性的过程，而非单纯的生产过程。\n软件开发具有 迭代性，需要不断地反复尝试，通过比较和选择不同的设计，最终确定令人满意的问题解决方案\n原型化模型：原型化模型需要 迅速建造 一个可运行的软件原型，它使用户和开发人员对系统的相关方面进行检查，以决定是否合适和恰当 需求原型化\n纸上原型 产品原型设计软件 阶段化开发：今天的商业环境需要快速地推出新产品，阶段化开发使得软件系统能够一部分一部分地交付，从而缩短软件开发周期。 增量模型：在每一个新的发布中逐步增加功能直到构造全部功能 迭代模型：一开始提交一个完整系统，在后续发布中补充完善各子系统功能 可转换模型：可转换模型师采用 形式化的数学方法 描述系统，并利用一系列转换将形式化的需求规格说明变为可交付使用的系统 数学方法具有严密性和准确性，形式化方法所交付的系统具有较少的缺陷和较高的安全性 网络公开课程：适用于增量模型或迭代模型 汽车防抱死系统：适用于可转换模型（形式化方法）\nChapter 2: 需求获取技术 # 软件需求 # 软件需求：是指利益相关方队目标软件系统的要求和期望，细分为：\n功能需求：描述系统应该具有的功能（控制 ⽉ 球 ⻋ 移动并到达指定地点） 性能需求：描述系统应该具有的性能（MCS 必须在 1 秒内完成最优路径规划） 可靠性需求：描述系统应该具有的可靠性（MCS 平均 ⽆ 故障 ⼯ 作时间必须 ⼤ 于 24 ⼩ 时） 约束性需求：描述系统应该满足的约束条件（MCS 必须在 10 个 ⽉ 内通过验收测试） 软件需求是整个软件项目的终极目标，也是后续软件开发活动的主要基础\n需求工程活动\n需求抽取（Elitication）：通过与用户交流，了解用户需求 需求分析（Analysis）：对需求进行分析，确定需求的优先级 需求规约（Specification）：将需求规约为文档 需求管理（Management）：管理需求变更 需求验证（Validation）：验证需求是否满足用户需求 需求抽取 # 需求抽取的目标、实质和关键\n需求抽取的目标 是主动与干系人协同工作，找出他们的需求，设别潜在的冲突，磋商解决矛盾，定义系统范围与边界 需求抽取的实质 是了解待解决问题及其所属领域； 需求抽取的关键 是确保问题的解决是有 商业价值 的 需求抽取技术\n抽取技术：协同工作、面谈、问卷调查、观察法、原型法、文档分析、建模、角色扮演、非功能性需求列表 冲突是被与磋商 需求抽取的出发点\n确定干系人：需要强调与客户的联络关系，系统的设计与谁的利益息息相关 定义边界：界定问题的范围，确定系统的边界 定义目标和情景实例：目标和情景实例是组织原始需求信息的有效手段 分析可行性：如何进行可行性研究，如何选择好的项目 分析风险：风险管理应长期、持续进行，而非阶段性、一次性的任务；进行灾难和事故分析以确定风险 Stakeholders：干系人是指与软件系统有关的所有人员，包括用户、开发人员、管理人员、维护人员、软件工程师等。让利益相关者参与个人或团体需求会议以定义系统详细信息 访谈技巧，启发式问题：\n访谈：同一时间，同一地点。Few People, Analyst-Driven 调查文卷：不同时间，不同地点。Many People, Analyst-Observer 小组讨论：相同时间，相同或不同地点，\u0026lt; 20 人，Analyst-Facilitated 观察：同一时间，同一地点，Analyst-Observer 原型、模型、大纲：澄清模糊或不确定的需求；简化需求文档和接受需求，向客户和最终用户提供早期反馈（A picture says a thousand words.） Prepare for Change\nThis is an “attitude” The more stakeholders are involved, the more features they will want • Don’t solve this “problem” by eliminating stakeholders Stakeholders have the right to change their minds • Don’t Ever Ask: “Ok, Is that Your Final Requirement?” See suggested changes as opportunities, not threats 需求分析 # 需求分析的目标、实质和关键\n目标：对产品及其环境的交互进行更深入的了解，识别系统需求，设计软件体系结构，建立需求与体系结构部件之间的关联，在体系结构设计实现过程中进一步识别矛盾冲突，并通过干系人之间的协调磋商解决问题 实质：概念建模，选择常用的建模语言，进行功能建模和信息建模 关键：体系结构设计与需求分配 通过评估需求的满足度来评价体系结构设计的质量 需求规约 # 需求规约是系统和软件需求的文档化，以便于后续的需求及系统正式评审而准备的规范化文档\n单个需求项的质量：准确、正确、明确、可行、可证 整个需求集合的质量：现实、精确、全面、一致 需求管理 # 需求管理是贯穿从需求获取到软件系统下线的全过程。需求管理设计软件配置管理、需求跟踪、影响分析和版本控制。\n需求跟踪：描述和追踪一条需求的来龙去脉的能力，包括向前追踪到软件制品，向后追踪到需求来源。 变更请求管理：系统化的变更管理 需求属性管理 需求验证 # 对其他需求工程活动的质量的保证。通过数学的形式化工具或工程化的测试过程来确保系统满足干系人的要求。 验证方法：评审、原型化、模型验证、确认测试\n需求种类\n用户需求，客户需求，业务需求\n软件需求，系统需求\n功能需求：As an actor(object), do what, so that (goal) 非功能需求 质量需求：安全性、可靠性、稳定性、可用性、可维护性、可移植性、可扩展性、兼容性 约束需求：预算、时间、技术等 需求获取的内容 # 功能需求：系统做什么，系统何时做什么，系统何时及如何修改或升级 性能需求：软件开发的技术性指标，规模大小、存储容量、可靠性、安全性 环境需求：硬件设备、软件设备 界面需求：来自其他系统的输入、输出到其他系统、数据格式、数据存储介质 接口需求：软件与其他软件或硬件的接口 用户或人的因素：用户需求、用户熟练程度、需何种培训 文档需求：用户手册、技术手册、培训手册 数据需求：数据的输入、输出、存储、数据流量 资源需求：人员、时间、预算、硬件、软件 安全需求 软件成本消耗与开发进度 质量保证 数据流图 DFD # 软件需求分析建模方法：\n结构化分析（传统建模方法）：数据流图、数据字典、实体关系图 面向对象分析：对象模型、功能模型、动态模型 数据流图（DFD，Data Flow Diagram）是一种描述系统功能的图形化工具，图中没有任何具体的物理元素，只是描绘信息在系统中的流动和处理情况。就图本身而言，并不是只有程序员，或计算机专业技术人员能够读懂，特别是需求方（客户，用户）也能读懂。 DFD 的基本元素 External Entity：外部实体，系统的输入输出来源，Source/Sink Processing：处理，对数据进行处理的过程，至少有一个输入和一个输出 Data Flow：数据流，数据在处理过程中的流动 Data Stores：数据存储，数据的存储位置 Describing letter：描述符号，用于描述数据流的内容 DFD 的基本规则\n流程的输入始终和输出不同 对象始终有唯一的命名 处理至少有一个输入和一个输出 数据无法直接从一个存储移至另一个存储 数据无法直接从外部源移动到数据存储 数据无法直接从数据存储移动到数据接收器 数据存储具有名词短语标签 数据无法直接从源移动到接收点 数据流在符号之间只有一个流动方向 数据流到数据存储意味着更新 来自数据存储的数据流意味着检索或使用 分叉意味着完全相同的数据从公共位置传输到两个或多个进程、数据存储或源/接收器 连接意味着完全相同的数据来自任何两个或更多不同的流程、数据存储或源/接收器到公共位置 DFD 分层 DFD 可以分为多个层次，每个层次都有不同的细节级别。最高层次的 DFD 称为 0 级 DFD，它是系统的总体概述。0 级 DFD 描述了系统的整体功能，而 1 级 DFD 描述了 0 级 DFD 中的每个功能的详细信息。1 级 DFD 可以进一步分解为 2 级、3 级 DFD 等。\nDFD 缺点：无法给出精确详细的定义，不能使用 DFDs 模拟系统\n数据字典 DD # 数据字典 DD 是对所有与系统相关的数据元素的一个有组织的列表, 以及精确的、严格的定义，使得用户和系统分析员对于输入、输出、存储成分和中间计算结果等有共同的理解。\n定义式中使用的符号\n操作符 含义描述 举例 = 被定义为 x = “a” + 与（顺序结构） x = a + b {\u0026hellip;} 重复（循环结构） x = {a}，x = 3{a}8 [\u0026hellip;|\u0026hellip;] 或（选择结构） x = [a, b]，x = [a|b] [\u0026hellip;,\u0026hellip;] 或（选择结构） x = [a, b] (\u0026hellip;) 可选 x = (a) “\u0026hellip;” 基本数据元素 x = “a” .. 连结符 x = 1..9 *\u0026hellip;* 注释符 这是注释内容 m..n 界域 x = 3..8 x = {a}: a 重复 0 次或多次\nx = 3{a}8: a 重复 3 次到 8 次\n实体关系图 E-R # 实体关系图 E-R 是一种用于描述系统中数据的结构化方法，它描述了系统中的实体、实体之间的关系和实体的属性。可用于描述数据流图中“数据存贮”及其之间的关系，它是数据库概念设计的最常用的工具。\nERD 的符号：\n实体用长方形表示\n实体的属性用椭圆形表示\n联系用菱形框表示\n用无向边把实体与其属性连接起来\nChapter 3: UML 与用例建模 # 面向对象分析模型：\n用例图 Use Case Diagram 类图和对象图 Class Diagram and Object Diagram 行为图 Behavior Diagram 面向对象：封装、继承、复用、对象 对象-类 类是描述和抽象; 对象是具体和实例化（instance） 类是对象定义，描述，设计时的称呼。 对象是类使用，调用，实例化时的称呼。类对应的程序运行使用的称呼 软件开发中为什么要使用面向对象方法？ 自然，接近现实 方便建模 模块化 封装与信息隐藏 继承复用 扩展修改维护容易 面向对象分析方法与结构化分析方法有哪些相似之处？有何区别？ 面向结构的方法是过程的集合，面向对象的方法是实体的集合 传统方法数据与过程分离，对象方法数据和处理数据的方法封装成一个单元 SOA 方法面向功能，OOP 方法面向对象，并确定实体间的关系，但两种方法并不排斥 面向对象方法是对过去的一个完全突破，还是“换汤不换药”？\n面向对象方法并不是对过去的完全突破，而是对传统方法的改进和扩展。它继承了传统方法中的许多优点，同时引入了新的概念和技术，如封装、继承和多态性，使得软件开发更加自然和接近现实世界。面向对象方法强调对象和类的概念，将数据和操作封装在一起，提高了系统的模块化和可维护性。因此，面向对象方法可以看作是对传统方法的优化和发展，而不是完全的颠覆。\nOOA 建立分析模型的 5 个基本原则 建立分析模型 5 个基本原则：\n建模信息域； 描述模块功能； 表示模型行为； 分解以模型显示更多细节； 早期模型表示问题的本质，而后期模型提供实现细节。 UML 基础 # UML 是统一建模语言（Unified Modeling Language）的缩写，是一种用于软件系统分析和设计的标准化建模语言。可视化、详述、构造、文档化 UML 语法（图的画法） 4 个重要的 UML 图 # 用例图 Use Case Diagram 用例图是从用户角度描述系统功能，是用户所能观察到的系统功能的模型图，用例是系统中的一个功能单元。 用例图列出系统重的用例和系统外的参与者，并显示哪个参与者参与了哪个用例的执行（或称为发起了哪个用例）。\n参与者 Actor：在系统外部与系统直接交互的人或事物 用例 Use Case：系统外部可见的一个系统功能单元。系统的功能由系统单元所提供，并通过一系列系统单元与一个或多个参与者之间交换的消息所表达。 用例图中的关系（边）及解释 泛化：箭头指向的为一般化 包含：箭头指向的为包含，必须执行 扩展：箭头指向的为扩展，可选执行 类图 Class Diagram 类图以反映类的组成（属性、操作），以及类之间的关系为主要目的，描述了软件系统的静态结构，是一种静态建模方法。类图包括类的内部结构和类之间的联系（关联、依赖、聚合等）。类是对现实世界中的事物（对象）的抽象。\n类图中的术语及解释\n类名：斜体为抽象类\n属性：属性名：属性类型, + 表示 public，- 表示 private，# 表示 protected，缺省值\n操作：操作名(参数列表:参数类型)：返回类型，+ 表示 public，- 表示 private，# 表示 protected，斜体为抽象操作\n接口：一组操作的集合，只有操作的声明，没有操作的实现 抽象类：不能实例化，只能作为其他类的父类，一般至少包含一个抽象操作 模版类：一种参数化的类，在编译时把模版参数绑定到不同的数据类型，从而产生不同的类 类图中的关系及解释\n关联关系：描述了类的结构之间的关系，具有方向、名字、角色和多重性等信息 一般关联：1...* 表示 1 至多个，0...1 表示 0 至 1 个；双向关联省略箭头 聚合关系：Aggregation，指明一个聚集（整体）和组成部分之间的关系。类图包含有实物和关系，类图不存在了，实物和关系还可用于其它的类图。 组合关系：Composition，语义更强的聚合，部分和整体具有相同的生命周期。类与关联关系之间有了组合关系，类不存在了，则相应的关联关系也不存在了。 泛化关系：在面向对象中一般称为 继承关系，存在与父类与子类、付接口与子接口之间 实现关系：对应于类和接口之间的关系，类 Circle、Rectangle 实现了接口 Shape 依赖关系：描述了一个类的变化对依赖它的类产生影响的情况。例如绑定（bind）、友元（friend）等 类图与代码的映射 类的映射、关联关系的映射、泛化关系的映射（class SavingsAccount:public Accout）、实现关系的映射（class Circle : public Shape, virtual void Draw();）、依赖关系的映射（模版类）\n顺序图 Sequence Diagram 顺序图用来表示 用例中的行为顺序，当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或状态机中引起转换的事件。顺序图展示对象之间的交互，属于 动态建模。顺序图的重点在 消息序列 上。 浏览顺序图的方法是 从上到下 查看对象间交换的消息。 顺序图中的术语及解释\n消息格式：operation(parameter list)，向哪个对象发送消息，实际上就是调用它的类中的操作 窄长方框用以强调这个部分处于活动状态 对象生命线表示从上到下的时间顺序，消息 1 在消息 2 之前发生，消息 2 在消息 3 之前发生 购票用例的顺序图： 状态图 Statechart Diagram 状态图说明对象在它的生命期中响应事件所经历的状态序列，以及它们对那些事件的响应，状态图用于揭示 Actor、类、子系统和组件的复杂特性，为 实时系统建模。\n状态图的组成\n状态，对象的状态是指在这个对象的 生命期中的一个条件或状况，在此期间对象将满足某些条件、执行某些活动，或等待某些事件。 转移，是 由一种状态到另一种状态的迁移。这种转移由被建模实体内部或外部事件触发。对一个类来说，转移通常是调用了一个可以引起状态发生重要变化的操作的结果。 状态图中的术语及解释 状态的可选活动表 Chapter 4 软件需求分析 # UML 分析模型 # UML 分析模型的三个视图\n功能模型：描述处理（数据变换），指明系统应该做什么 Use Case Diagram 对象模型：描述静态结构，定义做事情的实体 Class \u0026amp; Object Diagram 动态模型：描述交互过程，规定什么时候做何事 Sequence,State Diagram 面向对象分析的本质 3 个模型（功能、对象、动态），5 个层面（主题、类和对象、结构、属性、服务）\n典型用例建模方法（Use Case Diagram） 从和系统有交互的实体（外部用户）角度出发，描述系统应该具备哪些功能。\n系统边界：包围用例的方框，表示系统的范围，边界内的用例表示系统将来要实现的功能。 参与者：在系统边界之外，透过系统边界与系统进行有意义的交互的任何人或事物。 用例：由系统执行的一个动作序列，给 角色(actor) 提供一项有价值的服务。 关系：角色和用例、角色之间、用例之间有意义的 联系。 Use Case 图的建立步骤\n(1) 找出系统外部的参与者和外部系统，确定系统的边界和范围； (2) 确定每一个参与者所期望的系统行为； (3) 把这些系统行为命名为 Use Case； (4) 用泛化、包含、扩展等关系处理系统行为的公共或变更部分； (5) 编制和解释每一个 Use Case 的脚本； (6) 绘制 Use Case 图； [(7)] 区分主事件流和异常情况的事件流，可以把表示异常情况的事件流作为单独的 Use Case 处理； (8) 细化 Use Case 图，解决 Use Case 间的重复与冲突问题。 类建模方法（Class Diagram）\nThe key is finding objects\n如何提取类和对象？\n主题、类和对象、属性、服务、结构 主题是一种比类和对象抽象层次更高、粒度更大的概念，用以建立系统的高层抽象视图；中小型系统可只设一层主题，最多不超过两层；大型系统可只设两层主题，最多不超过三层。\n动态模型（Sequence, State Diagram)\n用来描述系统与时间相关的动态行为即系统的控制逻辑，表现对象彼此间经过相互作用后，随时间改变的不同运算顺序。 动态模型以“事件”（Events）和“状态”（States）为其模型的主要概念。\n需求规范（Requirements Specification） # 需求工程（Requirements Engineering）包括：Part 1：需求分析；Part 2：需求规范\nRequirements Specification 目的：\nTo provide a representation of the software for the customer’s review and approval Developed as a joint effort between the developer and the customer Serve as basis for review for both customer and developer Direct software design and development Culmination of requirements analysis Requirements Specification 质量：\n(1) unambiguous（明确的） (2) complete（完整的） (3) verifiable（可验证的） (4) consistent（一致的） (5) modifiable（可修改的） (6) traceable（可追踪的） Requirements Specification 的方法：\n可混合使用的模型：DFD、ERD、DD\u0026hellip;Use Case、Class Diagram、Sequence Diagram\u0026hellip; 使用但不限于面向结构，面向对象方法 IPO 图，在计算机领域 IPO 是指结构化设计中变换型结构的输入（Input）、加工（Processing）、输出（Output）。IPO 图是对每个模块进行详细设计的工具，它是输入加工输出(INPUT PROCESS OUTPUT)图的简称。 需求规格说明书\n# 1. 引言 - 1.1 系统的目的 - 1.2 系统范围 - 1.3 项目的目标与成功标准 - 1.4 定义、缩略语和缩写 - 1.5 参考文献 - 1.6 概述 # 2. 当前系统 # 3. 提议的系统 - 3.1 概述 - 3.2 功能需求 - 3.3 非功能需求 - 3.3.1 可用性 - 3.3.2 可靠性 - 3.3.3 性能 - 3.3.4 可维护性 - 3.3.5 实施 - 3.3.6 接口 - 3.3.7 包装 - 3.3.8 法律 - 3.4 系统模型 - 3.4.1 场景 - 3.4.2 用例模型 - 3.4.3 对象模型 - 3.4.4 动态模型 - 3.4.5 用户界面 # 4. 术语表 Chapter 5 总体设计 # 总体设计基础概念 # 软件需求 VS 软件设计\n软件需求解决的是“做什么”的问题，软件设计解决的是“怎么做”的问题 软件设计分为 总体设计 和 详细设计 软件需求：分析模型；软件设计：设计模型 总体设计 VS 详细设计\n总体设计：确定软件的结构以及各组成部分（子系统或模块）之间的相互关系 总体设计的任务：将复杂系统按功能 分成模块、确定每个模块的功能和模块之间的 调用关系、块间传递的信息、评价模块结构的质量。 详细设计：确定模块内部的算法和数据结构，产生描述各模块程序过程的详细文档 详细设计的任务：为每个模块进行详细的 算法设计，用某种图形、表格、语言等工具将每个模块吹了过程的详细算法描述出来；为模块内的 数据结构进行设计；对数据库进行物理设计（确定数据库的物理结构）； 什么是软件体系结构？\n软件体系结构定义了软件局部和总体计算部件的 构成。从整体看，软件体系结构是由结构- 和功能各异、相互作用的部件集合，按照层次构成的。 软件体系结构定义了组成部件之间的相互作用 关系。 软件体系结构定义了构成系统的合成原理、方法、原则 软件体系结构定义了构成系统应该遵守的 约束 的条件。 总体设计的任务：\n确定软件的组成 确定各组成部分的相互关系 确定软件的运行模式 确定软件的若干原则 软件设计方法： 结构化设计方法(SD) 面向对象的设计方法(OOD) 面向数据结构的设计方法(JSD 方法) 评估准则：经验启发式规则、模块化、抽象、信息隐蔽、信息局部化\n什么是好的软件体系结构：模块化（Modularization）、抽象（Abstraction）、信息隐蔽（Information Hiding）、注意点分散(Separation of Concerns)、耦合和内聚 (couple and cohesion)、策略和实现的分离 (separation of police and implementation)、接口和实现的分离 (separation of interface and implementation)、分而制之(Divide-and-conquer)、层次化 (hierarchy)\n总体结构的设计方法\n根据经验划分子系统结构：根据待解决的问题 特点 和用户需求\n结构模式或风格：Architectural Pattern or Style。单机、多机、网络、集中式、分布式、客户端/服务器（表示层、功能层、数据层）\n胖客户机和瘦客户机 三层 B/S 结构 分布式对象体系结构：对象之间不存在客户机和服务器的界限，接收服务者扮演客户机角色，提供服务者就是服务器；对象可能分布在网络的多个计算机上，通过中间件相互通信 由 DFD 图导出总体结构\nI-\u0026gt; P-\u0026gt; O 自顶向下，逐步细化\n最顶层的控制模块 Cm 协调下述从属的控制功能：\n（1）输入信息处理控制模块 Ci，协调对所有输入数据的接收； （2）变换中心控制模块 Ct，管理对内部形式的数据的所有操作； （3）输出信息控制模块 Co，协调输出信息的产生过程。 由类图导出总体结构\n总体设计的原则 # 模块化原理 # 模块化（Modularization）\nsuppose P1, P2 be two problems, function C(x) stands the complexity of problem x, function E(x) represents the cost of solving problem x, if C(P1) \u0026gt; C(P2) Then E(P1) \u0026gt; E(P2) Experiential rule: C(P1+P2) \u0026gt; C(P1) + C(P2) E(P1+P2) \u0026gt; E(P1) +E(P2)\n抽象（Abstraction）\nAbstractions allow you to understand the essence of a subsystem without having to know unnecessary details\n信息隐蔽（Information Hiding）\n模块中所包含的信息（包括数据和过程）不允许其它不需要这些信息的模块使用。 设计模块时，应使得一个模块内包含的信息（数据和过程）对于不需要这些信息的模块来说，是不能访问的。\n模块独立（Module Independence）\n耦合（Coupling）：对一个软件结构内不同模块间互连程度的度量。模块间的连接有 调用、返回、进入、跳出 等 无直接耦合：如果两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，这就是非直接耦合。这种耦合的 模块独立性最强。 数据耦合：一模块调用另一模块时，被调用模块的输入、输出都是简单的数据(若干参数)。属于 松散耦合。 控制耦合：一模块向下属模块传递的信息 (开关量、标志等控制被调用模块决策的变量) 控制了被调用模块的内部逻辑。可以将被调用模块的判定上移到调用模块中进行，改控制耦合为数据耦合。 公共耦合（公共数据区耦合）：一组模块引用同一个公用数据区，全局变量 内容耦合：一个模块直接访问另一个模块的内部数据结构，或者直接调用另一个模块的内部子程序。最不好的耦合形式。 内聚（Cohesion）：标志一个模块内各个处理元素彼此结合的紧密程度，理想的内聚模块只做一件事情。\n功能内聚：模块内的所有元素都是为了完成一个功能而设计的，缺一不可，内聚性最强 过程内聚，顺序内聚 时间内聚（经典内聚）：模块完成的功能在同一时间内执行，这些功能只因时间因素关联在一起。 追求：\n高内聚、低耦合 低耦合：尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，坚决避免使用内容耦合。 高内聚：优先使用功能内聚，尽量满足过程内聚，少用逻辑内聚，坚决避免偶然内聚。 模块独立性度量 # 深度：表示软件结构中控制的层数，它能粗略表示软件的复杂程度。 宽度：表示软件结构同一层内的模块总数。宽度越大系统越复杂，对宽度影响最大因素是模块的扇出。宽度太大可增加深度来减少。 扇出数：是一个模块直接控制（调用）的模块数目（5-9）。扇出越大模块越复杂。 扇入数：是直接调用的上级模块数（3-5）。扇入太大会增加模块接口数，违背模块独立性原则。 上级模块 下级模块 模块的作用域应该在控制域之内：\n模块的作用域：是指受该模块判定影响的所有模块数。 模块的控制域：是受这个模块直接或间接控制调用的模块数。 模块的控制范围：本身及其 所有下级模块。 模块的作用范围： 即 直接调用 的模块 Chapter 6 详细设计 # 详细设计初认识 # Detailed design = data structure+ algorithm\n软件定义阶段定义了问题结构，叫作软件设计的 一级蓝图。可用系统流程图表示、或数据流图表示、或用结构化语言表示、或以形式化软件设计语言表示。 软件总体设计确定了软件结构，即确定模块的划分、模块间的接口。可称作软件设计 二级蓝图。用结构图、Jackson 结构图、Warnier 图来表示、或用 HIPO 图来表示。 软件详细设计（也称软件算法设计、软件过程设计、软件逻辑设计）确定每个软件模块的实现算法，可称软件设计的 三级蓝图。可用 程序流程图描述、或用伪码描述。 OOA \u0026amp; OOD 软件复用（Reuse） # 软件复用的层次：\n知识重用 方法和标准重用 软件成分重用：项目计划、成本估算、体系结构、需求模型和规格说明、设计方案、源代码、用户文档和技术文档、用户界面、数据 面向对象设计的重用机制\n传统上：内部函数 面向对象：内部类（类构件） 实例重用 继承重用 多态重用 详细设计的描述 # 程序流程图（Program Flow Chart）：顺序、选择、循环。优点：简单直观；缺点：全局结构、数据结构难表示 N-S 盒图：顺序、IF-THEN-ELSE 分支、CASE 分支、循环、调用。 特点：\n（1）功能域（即某一具体构造的功能范围）有明确的规定，并且很只观地从图形表示中看出来；\n（2）想随意分支或转移是不可能的；\n（3）局部数据和全程数据的作用域可以很容易确定；\n（4）容易表示出递归结构。\nDo while C1 if C2 if C3 Do S1; if C5 S3; else S2; endif S4; until C4 S5; endif endif enddo Chapter 7 编码或实现 # 编码阶段的两个重要决策\n选择编程语言 选择编码标准或风格 编程语言的分类\n机器语言 汇编语言 高级语言 C++编程阶段：编译、链接、执行 编码风格具体体现\n标识符（符号名、变量名）的风格 注释的风格 序言性注释：给出程序的整体说明 功能性注释：嵌在源程序体中，用以描述其后的语句或程序段是在做什么工作 数据说明的风格 语句结构的风格 输入 ／ 输出的风格 程序 layout 风格 程序复杂性的度量\n程序复杂性： 模块内程序代码的复杂程度，例如行数，if 条件判断的个数，loop 循环的圈数等。\n算法的时间复杂性（执行的步数）和空间复杂性（占用的存储空间）\n复杂性度量方法\n代码行度量法\nMcCabe 度量法：计算环路复杂性的方法：根据图论，在一个强连通的有向图 G 中，环的个数由以下公式给出： V(G)＝ m－n ＋ p， 其中，V(G) 是图 G 中环路个数，m 是图 G 中弧数，n 是图 G 中结点数，p 是图 G 中的强连通分量个数。\nHalstead 的软科学法：度量操作码，操作数；运算符，运算对象\n预测方法： n1 表示程序设计时不同运算符(包括保留字)的个数， n2 表示程序设计时不同运算对象的个数， H 表示“程序长度”，则有 H=n1×log2 n1+n2 × log2n2 H 是程序长度的预测值 Chapter 8 软件测试 # 测试在软件开发中非常重视 The biggest cost in software development\n软件测试是为了发现错误而运行一个软件的过程。\n软件测试基本概念 # 软件测试的定义或目标（狭义） 测试是为了发现程序中的错误而执行程序的过程 一个好的测试用例 是发现了至今未发现错误的用例 一次成功的测试 是发现了至今未发现错误的测试 程序测试能证明错误的存在, 但不能证明错误不存在。 测试的目的是发现程序中的错误，为了证明程序有错, 而不是证明程序无错。 软件测试的定义或目标（广义）：用于确保软件符合其规范并满足用户要求的过程 Verification vs. validation Validation: Are we building the right product?The software should do what the users really require Verification: Are we building the product right?The software should conform to its specification V \u0026amp; V must be applied at each stage in the software process. 软件测试的两个方法 # 静态测试 Static Test # 基本特征是在对软件进行 分析、检查和审阅，不实际运行 被测试的软件。 静态测试约可找出 30 ～ 70%的 逻辑设计 错误. 对需求规格说明书、软件设计说明书、源程序做检查和审阅，包括： 是否符合标准和规范 通过结构分析、流图分析、符号执行指出软件缺陷 动态测试 Dynamic Test # 通过运行被测程序来检验软件的动态行为和运行结果的正确性 动态测试的两个基本要素： 被测试程序 测试用例（测试数据） 动态黑盒测试（闭着眼睛测试软件） 黑盒测试，也叫功能测试，是指测试人员不需要了解程序的内部实现，只关注系统的输入与输出，测试系统是否按照需求文档的要求正确执行。\n不深入代码细节 的测试方法称为动态黑盒测试。 软件测试员充当 客户 来使用它。 黑盒测试样例的设计方法：\n等价类划分法：将输入数据划分为若干个等价类，从每个等价类中选取一个数据作为测试数据。Equivalence analysis is the most widely used approach. 有效等价类：用于实现功能和性能的测试 无效等价类：用于测试那些所实现的功能和性能不符合规格说明书的要求 边界测试：更多错误往往会发生在输入域的边界。 边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况 测试边界上的合法数据, 以及刚超过边界的非法数据 错误推测法：根据经验、直觉和预感进行测试。缺省值、空白、空值、零、无输入条件 因果图法：相互组合，适合 有多个输入条件的组合，根据输入和输出之间的因果关系，构造因果图，从而设计测试用例 自动软件测试：人工测试耗时、需要回归测试，自动测试可以提高效率、减少人力成本 动态白盒测试（带 X 光眼镜测试软件） 白盒测试，也叫结构测试或透明盒测试，是指测试人员对被测试软件的内部结构、算法、代码逻辑等有充分的了解，基于程序的内部工作原理来 设计和执行测试用例。 白盒测试的样例设计规则：\n语句覆盖：每个语句至少执行一次 判定覆盖：每个判定的每个分支至少执行一次 条件覆盖：每个判定的每个条件的每个取值至少执行一次 判定/条件覆盖：每个判定的每个条件的每个取值至少执行一次，且每个判定的每个分支至少执行一次 条件组合覆盖：每个判定的每个条件的每个取值至少执行一次，且每个判定的每个条件的每个组合至少执行一次 路径覆盖：每个程序路径至少执行一次 点覆盖：每个判定的每个条件的每个取值至少执行一次，且每个判定的每个条件的每个组合至少执行一次，且每个程序路径至少执行一次，It is equal to statement coverage 边覆盖：每个程序的每条边至少执行一次，It is equal to branch coverage 软件测试的过程 # 软件测试的过程，即软件集成、形成过程：\n单元测试：集中对用 源代码 实现的, 每一个程序单元进行测试，检查各个程序模块是否正确地实现了规定的功能。\n集成测试：把已测试过的模块组装起来，主要对与设计相关的软件 体系结构 的构造进行测试。 模块组装集成方式\n一次性组装方式：整体拼装，一次性测试 增殖式组装方式：逐步组装成较大的系统，边组装边测试 增殖式组装方式\n自顶向下的增殖方式 自底向上的增殖方式：从程序模块结构的最底层的模块开始组装和测试。 混合增殖式测试：首先对 I/O 模块和关键算法模块进行测试，再自底向上组装成完整且独立的子系统，再由主模块开始自顶向下进行增殖测试 确认测试：检查已实现的软件是否满足了 需求规格说明 中确定了的各种需求，以及软件配置是否完全、正确。\n有效性测试（黑盒测试） 软件配置复查 Alpha 测试，Beta 测试 α 测试是由一个开发者在 开发环境下 进行的测试，也可以是 公司内部的用户 在模拟实际操作环境下进行的测试。 β 测试是由软件的多个用户，在 实际使用环境下 进行的测试。这些用户 返回有关错误信息给开发者。 验收测试 系统测试：把经过确认的软件纳入 实际运行 环境中，与其它系统成份组合在一起进行测试。 功能测试、非功能测试 其他测试：性能、恢复测试、配置测试、安全性测试、安装测试、兼容测试等等\n停止测试条件 # Testing is a trade-off between budget, time and quality.\n可靠性分析 # 可靠性：reliability of software 程序在给定的 时间间隔 内，按照规格说明书的规定，成功运行的概率。\n可用性：usability of software 程序在给定的 时间点，按照规格说明书的规定，成功运行的概率。\n公式： $$A_{use}=\\frac{T_{up}}{T_{up}+T_{down}}$$ $$A_{use}=\\frac{MTTF}{MTTF+MTTR}$$\nMTTF: 平均无故障时间 MTTR: 平均修复时间 MTTF 的计算\n符号表示\n符号 含义 ET total error before testing IT size of program to be tested τ time used by testing Ed(τ) found errors in [0, τ] Ec(τ) corrected errors in [0, τ] 两个基本假定\n$$ 0.005 \u0026lt;= ET / IT \u0026lt;= 0.02 $$ $$ MTTF \\propto 1 / \\text{hidden bugs} $$ 计算公式\n$$ \\text{MTTF} = \\frac{1}{K \\left( \\frac{E_T}{I_T} - \\frac{Ec(\\tau)}{I_T} \\right)} $$\n其中： ( K = 200 )\n$$ Ec = ET - \\frac{I_T}{K \\times MTTF} \\quad \\text{(stop rule)} $$\nPredicting total errors(ET)\n植入法：在程序中植入错误\n符号 含义 ( N_p ) number of errors planted ( n_p ) number of errors found within ( N_p ) ( n ) found new errors ( N ) total number of errors $$\\frac{N}{n}=\\frac{N_p}{n_p} =\u0026gt; \\frac{n_p}{N_p}=\\frac{n}{N}$$ $$N=N_p\\times\\frac{n}{n_p}$$\n分别测试法：区分标记故障和非标记故障\n符号 含义 ( N_1 ) found errors by person 1 （标记故障） ( N_2 ) found errors by person 2 （非标记故障，潜在故障） ( n_b ) found errors by both person1 and person 2 $$N=N_1 \\times N_2 / n_b$$\n调试 # 测试是识别错误的症状，调试是识别错误的原因。 Debugging\n软件调试是在进行了成功的测试之后才开始的工作. 调试的任务是进一步诊断和改正程序中潜在的错误 调试活动由两部分组成：性质原因和位置, 修改排除这个错误 调试工作是一个具有很强技巧性和经验性的工作 调试是通过现象，找出原因的一个思维分析的过程 通过 debuger 工具来进行 Most integrated development environments, such as JBuilder, include a debugger. 几种主要的调试方法\n强行排错法：内存打印、设置打印语句，跟踪程序执行过程 回溯法调试：小程序常用，人工沿着程序的控制流程回溯源代码，找出错误根源 归纳法调试：从一些线索(错误征兆)着手，通过分析它们之间的关系来找出错误。 演绎法调试：演绎法是一种从一般原理或前提出发，经过排除和精化的过程来推导出结论的思考方法。演绎法排错是测试人员首先根据已有的测试用例，设想及枚举出所有可能出错的原因做为假设；然后再用原始测试数据或新的测试，从中逐个排除不可能正确的假设；最后，再用测试数据验证余下的假设确是出错的原因。 Chapter 9 软件维护 # 软件的变化是不可避免的，关键是采取适当的策略，有效地实施和管理软件的变化！\n软件维护的概念 # 软件维护是软件开发工作完成以后，在用户使用期间，对软件所做的补充、修改和增加工作。 软件运行 ＝ 软件维护 在软件维护中，为 增加和改进软件的功能 所做的维护占 80%，而为改正错误所做的维护仅占 20%。 统计数据表明：实际上用于软件维护的费用占软件总费用的 55-80%。 软件维护比软件开发更困难，需要更多的创造性工作。 一般不涉及体系结构的重大变化 软件维护的类型 # 改正性维护：目的是识别和矫正功能 错误、性能 错误 和实现上的 错误。 Emergency Repairs Scheduled Repairs 适应性维护：使软件适应于 外界环境的改变 而对软件所做的修改工作。 完善性维护：为了 扩充软件的功能 或改善软件的性能对软件所做的改变。 预防性维护：为了 以后 更便于维护，或者为了改进可靠性，或者提供更好的基础便于将来提高性能而修改软件。可视为彻底的完美维护或维护的替代方案，Software Re-engineering 可维护性（Maintainability） # 软件可维护性是指软件被理解、改正、调整和改进的程度 提高可维护性可以通过进行明确的质量保证审查、改进程序的文档、提倡标准化、规范化开发\n再工程（Re-engineering） # Chapter 10 软件项目管理 # 项目是指为创建一个唯一的产品，或者提供唯一的服务而进行的努力活动。\n项目的特点： 目标性、周期性、约束性、不确定性\n软件项目的特点：\n对象：作为逻辑产品的软件 过程：不是以制造为主，无重复生产过程 属性：成本、进度、质量难以度量和估算 易变性：软件需求通常难以确定且经常变 复杂性：作为逻辑产品，复杂性非常高 软件项目管理的基本概念 # 软件项目管理是为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。\n团队分工 # 相关概念 # 基线（BaseLine）是已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变。基线标志着软件开发过程的各个里程碑（Milestone）。 ISO 9000：质量保证体系, 用于实现质量管理的组织结构、责任、规程、过程和资源。 CMM 名称：Capability Maturity Model for Software 目的：Improving the Software Development Process THE END\n","date":"2024-12-21","externalUrl":null,"permalink":"/docs/softwareengineering/","section":"文档","summary":"\u003ch1 class=\"relative group\"\u003e2024 软件工程复习 \n    \u003cdiv id=\"2024-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#2024-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTongji University. 2024/12/21 \u003cbr\u003e\nHyoung Yan\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e本文框架 \n    \u003cdiv id=\"%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%9C%AC%E6%96%87%E6%A1%86%E6%9E%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"2024%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%A1%86%E6%9E%B6.png\" alt=\"本文框架\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"2024 软件工程复习","type":"docs"},{"content":"","date":"2024-12-21","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","section":"Tags","summary":"","title":"软件工程","type":"tags"},{"content":" ONE # 二零二四年十二月四日，星期三，多云\n12月来了，2024年马上要结束了\nTWO # 读王老师书有感，摘抄一段：\n12 点，整个城市响起震耳欲聋的鞭炮声。在 10 楼观看，一番特殊心境。今年的鞭炮声比去年小，大概越来越文明了。广州、北京等地已经禁止放鞭炮，上海还没有坚决执行，只有宣传。\n看到一些高级礼花，小型的，大概很贵。也可以说明人们的生活水平在提高。我们放了一千响鞭炮，也不管文明不文明了。在这样的场合，人往往会有一种悲凉的感觉，越是热闹越是如此从中感受到自己生命的存在，感觉到世界是多么强大的外在力量，是可以不依人的感觉和情绪而存在的力量，是可以不依人的理性和理想而存在的力量。在平平淡淡的生活中，人们往往忘记了自己，觉得自己融入了社会和世界。但是，当世界沸腾起来时，才发现自己孤独安静的存在。\n在人生哲学上，王老师主张激进的入世主义和绝对理性，认为人应该单薄寡欲等等，他在书中写到：生活在这个世界上的人，有的是弱者，有的是强者；有的要别人来设定目标，有的给别人设定目标；有的需要感情支持生活，有的需要意志支持生活。我大概在每一对概念中都会选择做后一种人。\nTHREE # ","date":"2024-12-04","externalUrl":null,"permalink":"/posts/daily/2024-12-04/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style = \"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年十二月四日，星期三，多云\u003c/p\u003e\n    \u003cp\u003e12月来了，2024年马上要结束了\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e读王老师书有感，摘抄一段：\u003c/p\u003e","title":"2024 12 04","type":"posts"},{"content":"","date":"2024-12-04","externalUrl":null,"permalink":"/tags/%E5%A4%AA%E9%98%B3%E7%85%A7%E5%B8%B8%E5%8D%87%E8%B5%B7/","section":"Tags","summary":"","title":"太阳照常升起","type":"tags"},{"content":" ","date":"2024-11-22","externalUrl":null,"permalink":"/tabs/","section":"导航","summary":"\u003chr\u003e","title":"导航","type":"tabs"},{"content":" ONE # 二零二四年十一月七日，星期四，多云\n立冬了...天渐凉...\nTWO # 在上海第二次看到了星星，上一次在见到星星还是大一国庆去崇明岛玩。\n我以为星星消失了，因为我没有再见过星星\n想起一首歌，我想用它来记录冬天的到来。\n当你见天上星星，可有想起我。\nTHREE # 当你见到天上星星 可有想起我 可有记得当年我的脸 曾为你更比星星笑得多\n当你记起当年往事 你又会如何 可会轻轻凄然叹谓 怀念我在你心中 照耀过\n我像那银河星星 让你默默爱过 更让那柔柔光辉 为你解痛楚\n当你见到光明星星 请你想 想起我 当你见到星河灿烂 求你在心中记住我\n","date":"2024-11-17","externalUrl":null,"permalink":"/posts/daily/2024-11-07/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style=\"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年十一月七日，星期四，多云\u003c/p\u003e\n    \u003cp\u003e立冬了...天渐凉...\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e在上海第二次看到了星星，上一次在见到星星还是大一国庆去崇明岛玩。\u003c/p\u003e","title":"2024 11 07","type":"posts"},{"content":" 前言 # 一如济网\n同济大学无线网络提供三种接入服务(SSID):TJ-WIFI、TJ-GUEST-WIFI、eduroam\nTJ-WIFI 面向所有已开通统一身份认证或上网服务的在校师生及其他用户（tj 开头账户），采用 802.1x 接入方式，用户只需在首次登录时使用用户名及密码完成验证，再次连接时系统将会自动完成身份认证，无需重复输入； TJ-GUEST-WIFI 主要面向校外访客，采用 web 认证方式，通过手机验证码认证登录； eduroam 主要面向所有加入 eduroam 联盟（全球教育和学术领域无线漫游服务联盟）的其他高校师生或科研机构人员，采用 802.1x 接入方式，我校师生在其他提供该无线服务（SSID）的区域也可以使用该服务。 除此之外，在宿舍区域还有一种，TJ-DORM-WIFI，支持免费使用以及绑定宽带，但是如果长时间不使用，设备会被注销，基本一两天就要登录一次，较为麻烦，这也是写这个脚本的原因，主要针对 Windows 端。\n思路 # 脚本较为简单，其实核心就是一个 GET 请求，在此基础上进行了一些逻辑判断。\n分析验证方式 # 打开 TJ-DORM-WIFI 的登录页面 页面较为简单，只需要输入账号密码即可登录，此外如果绑定了宽带账号，可以选择【中国移动】、【中国联通】等，这里默认校园网账号登录。 检查请求方式 在登录页按 F12 打开开发者工具，切换到 NetWork 选项卡，勾选保留日志，然后输入学号密码登录，查看请求方式，可以看到是 GET 请求方式。 分析请求参数 点击第一个资源文件，查看Header表头参数，查看 URL 格式，发现请求的 URL 中带有学号密码明文，到这步也就知道了校园网自动认证的原理，甚至学号密码都没有加密，我们可以构造一个 GET 请求，传递此 URL 参数即可完成登录。 验证登录 复制请求 URL，注销校园网登录，然后在地址栏粘贴请求 URL，发现返回一些信息，同时校园网登录成功。也就是说最关键的就是构造这个 URL 请求。 参数分析 # LOGIN_IP\n描述：登录页面的基础 URL\n示例：\u0026quot;http://172.21.0.54/\u0026quot;\nNOT_SIGNED_IN_TITLE\n描述：用户未登录时页面的标题\n示例：\u0026quot;上网登录页\u0026quot;\nRESULT_RETURN\n描述：登录请求返回的成功标识\n示例：'\u0026quot;result\u0026quot;:1'\nTIMEOUT\n描述：请求的超时时间（秒） RETRY_DELAY\n描述：请求失败后的重试等待时间（秒） MAX_RETRIES\n描述：最大重试次数 USERNAME\n描述：用户的学号\n示例：\u0026quot;2253666\u0026quot;\nPASSWORD\n描述：用户的密码 SIGN_PARAMETER\n描述：登录请求的完整 URL，包含用户名和密码 示例：f\u0026quot;http://172.21.0.54/drcom/login?callback=dr1003\u0026amp;DDDDD={USERNAME}\u0026amp;upass={PASSWORD}\u0026amp;0MKKey=123456\u0026amp;...\u0026quot; SIGNED_IN_TITLES\n描述：登录成功后可能出现的页面标题 示例：[\u0026quot;登录成功页\u0026quot;, \u0026quot;注销页\u0026quot;] 配置 # 思路：编写脚本通过 GET 方法请求登录页面，传递学号密码参数，完成登录。为了实现自动登录，可以使用任务计划程序实现，也可以借助油猴插件，每次访问网页时自动检测并登录。\n01 油猴脚本 # 使用大名鼎鼎的油猴扩展插件，编写简单的脚本程序，每次打开浏览器访问网页时检测是否可以访问互联网，如果不能访问，则使用 GET 方法请求登录页面，传递学号密码参数，完成登录，并刷新页面。 02 Python 脚本 # 使用 Python 编写脚本，通过 GET 方法请求登录页面，传递学号密码参数，完成登录，然后使用任务计划程序定时执行脚本，实现自动登录。\n但是貌似这种方法有点麻烦，因为 Python 需要导入一些第三方包，不如第一种简单。\n第一种属于浏览器脚本，不能操作系统设置，借助 Python 及其强大的第三方包，可以使脚本更灵活，比方 version2 相比之前添加了切换 WIFI 的功能，自动切换到 TJ-DORM-WIFI，并且添加了系统通知、错误重连等功能，但是十分简陋，还好勉强可用。\n需要导入的库有：\npip install requests pip install win11toast pip install asyncio\n修改相关参数 login_IP 改为学校校园网登录的 IP 地址，并添加 http not_sign_in_title 改为校园网未登录状态的页面标题 result_return 改为登录成功页面中的标识（上面响应串中的\u0026quot;result\u0026quot;:1）\nsign_parameter 改为电脑端的请求 URL signed_in_title 改为校园网已登录状态的页面标题 添加任务计划，每次开机自动执行脚本，实现自动登录\n搜索并打开任务计划程序，创建任务 修改权限和配置 添加触发器 添加条件 添加操作 因为 Python 脚本需要解释器，需要配环境，太麻烦，所以把 Python 脚本转成了 exe 可执行文件，这样更方便一些。 03 批处理命令 # 也可以使用批处理命令，其实方法很多，核心部分就是通过 GET 方法请求登录 URL，而且不涉及任何加解密、验证码验证。\n@echo off REM 使用curl执行GET请求访问校园网登录URL set USERNAME=你的学号 set PASSWORD=你的密码 set LOGIN_URL=http://172.21.0.54/drcom/login?callback=dr1003^\u0026amp;DDDDD=%USERNAME%^\u0026amp;upass=%PASSWORD%^\u0026amp;0MKKey=123456^\u0026amp;R1=0^\u0026amp;R2=^\u0026amp;R3=0^\u0026amp;R6=0^\u0026amp;para=00^\u0026amp;v6ip=^\u0026amp;terminal_type=1^\u0026amp;lang=zh-cn^\u0026amp;jsVersion=4.1^\u0026amp;v=2952^\u0026amp;lang=zh curl -X GET \u0026#34;%LOGIN_URL%\u0026#34; exit 代码部分 # 较为简单，可以自行修改\nnull 参考 # 理论上各大高校都适用的全平台校园网自动登录实现方法 ","date":"2024-10-30","externalUrl":null,"permalink":"/docs/tj-dorm-wifi-auto-login/","section":"文档","summary":"\u003ch2 class=\"relative group\"\u003e前言 \n    \u003cdiv id=\"%E5%89%8D%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一如济网\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e同济大学无线网络提供三种接入服务(SSID):\u003ccode\u003eTJ-WIFI\u003c/code\u003e、\u003ccode\u003eTJ-GUEST-WIFI\u003c/code\u003e、\u003ccode\u003eeduroam\u003c/code\u003e\u003c/p\u003e","title":"Tongji-DORM-WIFI自动登录","type":"docs"},{"content":"","date":"2024-10-30","externalUrl":null,"permalink":"/tags/%E5%B7%A5%E5%85%B7/","section":"Tags","summary":"","title":"工具","type":"tags"},{"content":"","date":"2024-10-30","externalUrl":null,"permalink":"/tags/%E5%90%8C%E6%B5%8E/","section":"Tags","summary":"","title":"同济","type":"tags"},{"content":"","date":"2024-10-30","externalUrl":null,"permalink":"/tags/%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"网络","type":"tags"},{"content":" 介绍 # Follow,下一代的聚合信息浏览器\nFollow 为用户提供了一个全新的信息聚合平台，但远不止于此。\n什么是 RSS？ # RSS（Really Simple Syndication） 简单来说就是把信息源聚合在一起，在一个地方接受所有信息源的更新信息、摘要甚至全文，对于多信息源的场景非常必要。\nRSS 定义了非常简单的方法来共享和查看标题和内容，它基于 XML 格式编写，可以自动更新，允许为不同的网站进行视图的个性化。\n为什么选择 RSS？ # RSS 最吸引人之处，在于它能让你看到「开放互联网未经过滤的样子」，给你一个「自己决定看什么」的机会。\n在这个信息爆炸的时代，如何及时、快速获取信息？如何避免被信息淹没？以个人为例，我常用的平台有微信公众号、知乎、B 站等。除此之外，也会关注一些独立博客、新闻网站等。但是当我们关注的信息源超过个位数，就不再可能通过偶尔打开来获取信息更新了，费时费力，而且下载各种各样的 APP 实在让人心烦。这时候，你倒可以去尝试一下 RSS，相信你会被它的简洁、高效的聚合特性所吸引。\n为什么选择 Follow？ # 当然，如果你用过 RSS，你会发现，大多数 RSS 阅读器信息源较少，虽然有 RSSHub 等工具，但是对于普通用户来说，使用门槛较高，你需要自己去添加订阅源，有的费了千辛万苦找到了却因为没人维护不再可用。 而 Follow 则是一个专注于信息聚合的平台，它提供了更多的信息源，更多的分类，更多的个性化设置，更多的社交功能，更多的阅读体验。简单来说就是，Follow 为你提供了一个快速上手，界面美观的 RSS 工具，不管你是第一次听说 RSS 还是 RSS 重度用户，Follow 都能满足你的需求，All in One。 功能特性 # 嘿，不要问那么多为什么了，快下载下来试试。\n功能特性：\n多元化的内容聚合 Follow 的核心优势在于其强大的内容聚合能力，用户可以在会这个统一的平台上关注并管理来自各种来源的信息，包括但不限于： 网站和博客\n社交媒体账号\n博客节目\n各类通知和更新\n这种集中化的管理方式大大简化了用户的信息获取流程，让他们能够更加高效地掌握感兴趣的内容动态。 在公测这段时间，Follow 已经收录了许多优质的信息源，包括知乎、微博、B 站、YouTube、Medium、微信公众号等，后续估计也会覆盖越来越多的信息源，可以节省用户许多时间。 颜值即是正义 Follow 的设计风格简洁大方，界面美观，操作简单，支持多种功能自定义。目前有 Windows、Mac、Linux 和 Web 端，满足了不同用户的需求，后续可能推出 Android 和 iOS 版本。\nFollow 为不同类型的内容静心设计了独特的展示方式，文章、社交媒体帖子、图片、视频、播客等都有专属的视图，力求为用户提供媲美甚至超越原平台的浏览体验。 人工智能赋能 现在啥软件都整 AI+，Follow 也如此，提供了 AI 翻译、AI 智能摘要、AI 推荐等功能，让你的阅读体验更加智能化。 区块链激励机制 Follow 创新性地引入了区块链技术，通过 Power Token 构建了一个独特的生态系统：\n活跃用户可以获得 Token 奖励，享受更多高级服务。\n优质内容创作者能够获得直接的经济回报，激励持续创作。\n形成了一个良性循环的生态系统，促进高质量内容的产出和传播。\n这学期报了区块链技术课，但是没怎么认真听，不甚了解。\n亲自试试 # 由于 Follow 正处于公测阶段，免费用户仅可导入 5 个信息源，某些功能需要邀请码才可体验。所以可以先导入几个体验一下，邀请码可以到闲鱼买，一瓶饮料钱。\nGithub：https://github.com/RSSNext/Follow\n官网：https://follow.is/\n","date":"2024-10-26","externalUrl":null,"permalink":"/docs/follow_the_rss_reader/","section":"文档","summary":"\u003ch2 class=\"relative group\"\u003e介绍 \n    \u003cdiv id=\"%E4%BB%8B%E7%BB%8D\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFollow,下一代的聚合信息浏览器\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFollow 为用户提供了一个全新的信息聚合平台，但远不止于此。\u003c/p\u003e","title":"Follow,下一代的聚合信息浏览器","type":"docs"},{"content":"","date":"2024-10-26","externalUrl":null,"permalink":"/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","section":"Tags","summary":"","title":"软件推荐","type":"tags"},{"content":"","date":"2024-10-26","externalUrl":null,"permalink":"/tags/%E9%98%85%E8%AF%BB/","section":"Tags","summary":"","title":"阅读","type":"tags"},{"content":" ONE 阅读记录 # 变形记是卡夫卡的代表作之一，本作很短，后半部分是作者的小传。读卡夫卡的《变形记》有一种被撕裂、吞噬的感觉，作者的笔触十分悲凉，让人看到人物自我救赎却又陷入毁灭的无望追寻。\n卡夫卡小说的一大主题：对困境的顺从。卡夫卡认为困境是人生的常态，观察困境中人的生活，人于其中克服困境的，是浪漫主义或英雄史诗；而人被困境裹挟，乃是人生常态。关注常态下人的境遇，是现代小说的标志。\n一九一五年该作首度问世时，卡夫卡曾在一封信中特别声明，这只怪虫的形象不能予以具象化。的确，有人认为这只怪虫是众多苦难的象征，个人认为，人人心中都有那么个怪虫，不尽相同，不予之具象化，也许更能引人深思，同心中的怪虫沟通。\nTWO 内容回顾 # 此书开篇讲述了格里高尔一觉醒来变成了一只甲虫，异形的他再也无法融入原来的生活、工作中去。然而不管格里高尔是变成甲虫前还是变成甲虫后，都是那么努力地活着，担心家人的生活。格里高尔饱受变身后的煎熬，但他从未考虑过自己的感受，有点像讨好型人格，所有的付出和努力在家人眼中已经习以为常，因此当他失去了人的价值，家人也逐渐开始嫌弃他的存在。最终格里高尔在冷漠中死去。\nTHREE 三五七言 # 一本书必须是一柄斧头，凿开我们心中冰封的海洋。\n噢，这世上是有希望，无穷的希望。只是你我没有。\n","date":"2024-10-26","externalUrl":null,"permalink":"/posts/books/04_%E5%8F%98%E5%BD%A2%E8%AE%B0/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE 阅读记录 \n    \u003cdiv id=\"one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e    变形记是卡夫卡的代表作之一，本作很短，后半部分是作者的小传。读卡夫卡的《变形记》有一种被撕裂、吞噬的感觉，作者的笔触十分悲凉，让人看到人物自我救赎却又陷入毁灭的无望追寻。\u003c/p\u003e","title":"【书评】变形记","type":"posts"},{"content":"","date":"2024-10-26","externalUrl":null,"permalink":"/tags/%E4%B9%A6%E8%AF%84/","section":"Tags","summary":"","title":"书评","type":"tags"},{"content":" ONE 阅读记录 # 三月，天空中纷洒着似雨似雪\n情绪反扑，唯有读书可以让我静下心来，这两天也真是疯魔了，一天一本。\n花了两个小时读了王蒙的《组织部来了个年轻人》，乍一听书名想到了小王 hhh，能文能武，长相十分英俊。\n本书写于 1956 年，恰值“双百方针”实行时期，毛主席曾 5 次评论这本小说，认为是一本反对官僚主义的小说，此书在当时引起不小的反响，众人就“北京是否有官僚主义”等问题展开争论。\n次年王蒙被划为右派，在新疆生活了十六年之久，然而所谓“祸兮福之所倚，福兮祸之所伏”，作者也因此躲过了十年浩劫，并于 1979 年得以平反，此后还出任了文化部部长等职务，看别人的人生总是很有趣，短短几句话，有多少故事在其中。 TWO 内容回顾 # 小说以处理麻袋厂党支部官僚主义问题作为中心情节展开叙述，讲述了新进组织部的年轻人林震与官僚主义者的斗争。人物是复杂的，立体的，一腔热血的主人公林震心性纯良，不愿同流合污但在工作中却缺乏经验；刘世吾思维敏捷，老道成熟但随波逐流；薛常新圆滑变通但能力极强，混的风生水起。小说虽然写于 1956 年，但是近七十年过后，又一个年轻人看后，觉得里面的场景仿佛就发生在当今。\n本文篇幅不长，后文一多半都是作者的补充和他人评价。暂且不论教员的评价是否出于政治因素，也不论某些政策是否是“引蛇出洞”，也不论本文是否确有“影射之意”。不妨把目光放远，书中的某些问题似乎是永恒的，如同心脏里的灰尘，金子中的杂质，我还是暂时认为水至清则无鱼，合金比足金更易留存，可无论如何，对于纯金的追求应该始终不变。\nTHREE 三五七言 # 一 理想主义的课堂教着白 现实主义的课堂说着黑 而我，从明天起 做一个灰色的人，在灰色地带游走着\n二 现在二十二岁，他的生命史上好像还是白纸，没有功勋，没有创造，没有冒险，也没有爱情——连给某个姑娘写一封信都没做过。\n三 年轻人都这样，最初互相美化，慢慢发现了缺点，就觉得都很平凡。\nFOUR 致自己 # 你是选择做林震还是刘世吾？在回答之前，不妨告诉 20 岁的自己，在白纸般的人生上多一些尝试，多一些勇敢。\n","date":"2024-10-19","externalUrl":null,"permalink":"/posts/books/03_%E7%BB%84%E7%BB%87%E9%83%A8%E6%9D%A5%E4%BA%86%E4%B8%AA%E5%B9%B4%E8%BD%BB%E4%BA%BA/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE 阅读记录 \n    \u003cdiv id=\"one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e三月，天空中纷洒着似雨似雪\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e情绪反扑，唯有读书可以让我静下心来，这两天也真是疯魔了，一天一本。\u003c/p\u003e","title":"【书评】组织部来了个年轻人","type":"posts"},{"content":" ONE 阅读记录 # 如果你抑郁，是因为你活在过去；\n如果你焦虑，是因为你活在未来；\n如果你内心平静，说明你活在当下。\n用时五天读完了这本书《蛤蟆先生去看心理医生》，曾经听书名以为是童书，其实是一本很有趣且有深度的心理疗愈读物。\n曾经以为这种心理/哲学相关的书会很枯燥，读不下去，其实还是因为没有用心去读去尝试。在读书的过程中，收获了很多有趣的知识，比方人生的三大状态：儿童自我状态、父母自我状态、成人自我状态，成年人的行为习惯都是从童年学来的，也会潜移默化地影响人的一生，原谅过去实际也是学会自洽。\nTWO 内容回顾 # 蛤蟆先生是一只不吃天鹅肉的好蛤蟆，在别人眼中他温文尔雅，风度翩翩，虽然也时而出丑，做些傻事，可是生活自由且快乐。俗话说“世上的事情，件件藏着委屈。”蛤蟆先生最近就因为一些变故，变得越来越抑郁，仿佛坠入了深渊，成了井底之蛙。在朋友的帮助下，蛤蟆先生找到了心理咨询师苍鹭，在苍鹭的引领下开始探索自己的内心世界，不断地认识自己、接纳自己、改变自己，最终开始蜕变。 不同于童话结尾，蛤蟆先生并未变成青蛙王子，而是变成了一个活在当下，追求未来的“成人自我”。本书以 10 次心理访谈开始，以蛤蟆先生和朋友各奔前程作结，完成了一次自我的疗愈。\nTHREE 三五七言 # 没有一种批判比自我批判更强烈，也没有一个法官比我们自己更苛刻。\n部分摘自微信读书[西小北]的书评，写的很好： 本书重点可概括为“1+2+3+4”：\n1 个前提。改变的唯一前提是认识你自己，在这个世界上能帮你的人只有你自己。\n2 个思维。人人在理性与感性之间徘徊，真正厉害的人，是理性与感性并存。之前的我，更像是感性大于理性，置身事外还可保持冷静，但是深陷其中，亲身体会，才会明白在感性中保持理性如何之难。\n3 个状态。每个人都有儿童、父母及成人的自我状态，三位一体，成年人之所以痛苦，恰恰是因为不在成人状态。而每个人都有这三种状态，不必怀疑处在儿童自我状态的你是否有父母状态，想想是否有时候自己会因为某件小事苛责自省。\n4 个坐标。人生有四个坐标，你选择的坐标决定了你成为什么样的人，“我好，你也好”是个动态的过程，选择它使我们奋斗的终极目标。 FOUR 致自己 # 你看向哪里？\n你要看向自己。\n做只快乐的蛤蟆先生吧，不要被自己困住，学会自洽，学会自省而不是自我批判。\n继续做只善良的蛤蟆吧，原谅过去，活在当下。\n","date":"2024-10-17","externalUrl":null,"permalink":"/posts/books/01_%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE 阅读记录 \n    \u003cdiv id=\"one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one-%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果你抑郁，是因为你活在过去；\u003cbr\u003e\n如果你焦虑，是因为你活在未来；\u003cbr\u003e\n如果你内心平静，说明你活在当下。\u003c/p\u003e","title":"【书评】蛤蟆先生去看心理医生","type":"posts"},{"content":" 1\n夏天的隅落里，我想起远方的不幸\n作为背景的光幕突然被影子犁开\n上楼的声音渐渐远了\n2\n当窗外的风推开街道，当我\n复述着意义消散的故事\n谁也不知道时辰如此之新\n像是猫的线条\n3\n偶尔，空无一字的纸要我解释它\n我说好吧，我把词从你体内\n驱赶出来，用日常的训诫\n和窥视者无垠的耐心\n4\n一首诗因而独自在阳光下发烫\n它没有燃烧，也没有暴漏自己的\n清逸，它只是和我一样抛锚在\n一个不那么痛苦的时刻\n","date":"2024-10-16","externalUrl":null,"permalink":"/posts/daily/2024-10-16/","section":"帖子","summary":"\u003cblockquote\u003e\n\u003cp\u003e1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e夏天的隅落里，我想起远方的不幸\u003c/p\u003e\n\u003cp\u003e作为背景的光幕突然被影子犁开\u003c/p\u003e\n\u003cp\u003e上楼的声音渐渐远了\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e2\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当窗外的风推开街道，当我\u003c/p\u003e\n\u003cp\u003e复述着意义消散的故事\u003c/p\u003e\n\u003cp\u003e谁也不知道时辰如此之新\u003c/p\u003e\n\u003cp\u003e像是猫的线条\u003c/p\u003e","title":"2024 10 16","type":"posts"},{"content":"","date":"2024-10-16","externalUrl":null,"permalink":"/tags/%E4%B8%89%E4%BA%94%E4%B8%83%E8%A8%80/","section":"Tags","summary":"","title":"三五七言","type":"tags"},{"content":" ONE # 二零二四年十月十三日，星期日，多云转阴\nTWO # Love Is Over\n这首歌有很多版本，但还是觉得这一首最好听，我们要快快乐乐的，我们不应该停留在回忆，停留在过去，而是应该多看看远方，多看看未来，多看看自己。\nLove is over，但是，这几天的太阳还是照常升起不是吗？ 昨天傍晚时分，在校园里溜达，原来学校这么美，这么安静可爱。\nTHREE # FOUR # ","date":"2024-10-13","externalUrl":null,"permalink":"/posts/daily/2024-10-13/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style=\"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年十月十三日，星期日，多云转阴\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003ctext\u003eLove Is Over\u003c/text\u003e\u003c/p\u003e","title":"2024 10 13","type":"posts"},{"content":"","date":"2024-10-08","externalUrl":null,"permalink":"/tags/fixbugs/","section":"Tags","summary":"","title":"Fixbugs","type":"tags"},{"content":" 问题描述 # 本着尝鲜的目的，更新了 Windows 11 24H2 版本，24H2 版本添加了些新功能，比方sudo命令，但是出乎意料又合理之中的是遇到了一些小问题，比方当鼠标聚焦在文本输入框时，光标会消失，鼠标正常移动。 猜测应该是图标显示的问题，果然网上检索，发现问题根源在于更新后的系统改变了鼠标指针的默认设置，引发了某些应用程序的兼容性问题。 针对这一问题，微软方面建议用户手动将鼠标指针恢复默认状态。 解决方案 # 开始面板搜索鼠标，打开鼠标设置。 在指针选项中，将指针选项卡中的指针下拉菜单选择为Windows 默认。 在自定义区域中，选中文本选择，点击浏览，选中beam_r.cur，点击打开。 保存退出，即可解决问题。 ","date":"2024-10-08","externalUrl":null,"permalink":"/docs/fixbugs/24h2_where_is_my_cusor/","section":"文档","summary":"\u003ch2 class=\"relative group\"\u003e问题描述 \n    \u003cdiv id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本着尝鲜的目的，更新了 Windows 11 24H2 版本，24H2 版本添加了些新功能，比方\u003ccode\u003esudo\u003c/code\u003e命令，但是出乎意料又合理之中的是遇到了一些小问题，比方当鼠标聚焦在文本输入框时，光标会消失，鼠标正常移动。\n猜测应该是图标显示的问题，果然网上检索，发现问题根源在于更新后的系统改变了鼠标指针的默认设置，引发了某些应用程序的兼容性问题。\n针对这一问题，微软方面建议用户手动将鼠标指针恢复默认状态。\n\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"image.png\" alt=\"alt text\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"我请问24H2，我的光标在哪里？","type":"docs"},{"content":" 问题描述 # 运行 jar 包时出错：在命令行中可以运行 jar，但是双击 jar 文件无反应或者闪退 cmd 命令\n解决方案 # 首先确定 Java 运行环境已经安装好，包括 JDK 或 JRE。可在命令行输入java -version查看是否安装成功。 如果在命令行中输入java -jar xx.jar可以运行，则说明是打开方式设置的问题。可右键 jar 文件，选择“打开方式”，选择“Java(TM) Platform SE binary”或浏览找到javaw.exe。 如果双击仍然无反应或闪退，则可 Win+R，键入regedit代开注册表编辑器，找到HKEY_CLASSES_ROOT\\Applications\\javaw.exe\\shell\\open\\command，检查值是否少了-jar参数（注意无引号）,修改后应为\u0026quot;C:\\Program Files\\Java\\jre1.8.0_281\\bin\\javaw.exe\u0026quot; -jar \u0026quot;%1\u0026quot;，保存退出即可解决问题。 ","date":"2024-10-08","externalUrl":null,"permalink":"/docs/fixbugs/run_the_jar/","section":"文档","summary":"\u003ch2 class=\"relative group\"\u003e问题描述 \n    \u003cdiv id=\"%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e运行 jar 包时出错：在命令行中可以运行 jar，但是双击 jar 文件无反应或者闪退\ncmd 命令\u003c/p\u003e","title":"命令行可执行jar包，但是无法双击运行","type":"docs"},{"content":" ONE # 二零二四年十月三日，星期四\n记二零二四年国庆\n微风不燥，阳光甚好\nShanghai 🚲 Kunshan\nTWO # A part of THREE # ","date":"2024-10-03","externalUrl":null,"permalink":"/posts/daily/2024-10-3/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style=\"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年十月三日，星期四\u003c/p\u003e\n    \u003cp\u003e记二零二四年国庆\u003c/p\u003e\n    \u003cp\u003e微风不燥，阳光甚好\u003c/p\u003e\n    \u003cp\u003eShanghai 🚲 Kunshan\u003c/p\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eA part of\n\n\n\u003cdiv id=\"gallery-7f1eebe14c601cd3ae9ed66895580d64\" class=\"gallery\"\u003e\n  \n\u003cimg src=\"pics/pic9.jpg\" class=\"grid-w22\" /\u003e\n\u003cimg src=\"pics/pic1.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic4.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic5.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic3.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic6.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic7.jpg\" class=\"grid-w33\" /\u003e\n\u003cimg src=\"pics/pic8.jpg\" class=\"grid-w33\" /\u003e\n\n\u003c/div\u003e\u003c/p\u003e","title":"2024 10 3","type":"posts"},{"content":" 介绍 # 《Hello 算法》：动画图解、一键运行的数据结构与算法教程 支持 Python, Java, C++, C, C#, JS, Go, Swift, Rust, Ruby, Kotlin, TS, Dart 代码 适合初学者，从零开始学习数据结构与算法 免费电子书，界面美观 访问 # Github 仓库 Hello 算法 在线阅读地址 ","date":"2024-09-28","externalUrl":null,"permalink":"/docs/hello_algo/","section":"文档","summary":"\u003ch3 class=\"relative group\"\u003e介绍 \n    \u003cdiv id=\"%E4%BB%8B%E7%BB%8D\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e《Hello 算法》：动画图解、一键运行的数据结构与算法教程\u003c/li\u003e\n\u003cli\u003e支持 Python, Java, C++, C, C#, JS, Go, Swift, Rust, Ruby, Kotlin, TS, Dart 代码\u003c/li\u003e\n\u003cli\u003e适合初学者，从零开始学习数据结构与算法\u003c/li\u003e\n\u003cli\u003e免费电子书，界面美观\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg\n        class=\"my-0 rounded-md\"\n        loading=\"lazy\"\n        srcset=\"\n        /docs/hello_algo/demo_hu14182871113745596788.gif 330w,\n        /docs/hello_algo/demo_hu3589642108854225774.gif 660w,\n        /docs/hello_algo/demo_hu2382235370839721109.gif 1024w,\n        /docs/hello_algo/demo_hu1664597185007674672.gif 2x\"\n        src=\"/docs/hello_algo/demo_hu3589642108854225774.gif\"\n        alt=\"动画图解\"\n      /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"Hello 算法, 带有动画图解的数据结构与算法教程","type":"docs"},{"content":"","date":"2024-09-28","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":" 介绍 # 这是一款全平台通用的换源工具/框架，目标支持 Linux, Windows (MSYS2, Cygwin), macOS, BSD 等尽可能多的操作系统环境，龙芯、飞腾、RISC-V 等尽可能多的 CPU。\n特性 # chsrc 不仅是一个命令行工具，同时也是一个换源框架，它甚至使你能够在不了解 C 语言的情况下编写出新的换源方法。\n立刻为一个新软件添加换源方法！添加自定义源\n安装 # Windows 通过 scoop 安装：$ scoop install chsrc\n手动下载：\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-x64-windows.exe -o chsrc.exe\nLinux\ncurl -L https://gitee.com/RubyMetric/chsrc/releases/download/pre/chsrc-x64-linux -o chsrc; chmod +x ./chsrc\nmacOS\nbrew install chsrc\n","date":"2024-09-28","externalUrl":null,"permalink":"/docs/change-the-source/","section":"文档","summary":"\u003ch3 class=\"relative group\"\u003e介绍 \n    \u003cdiv id=\"%E4%BB%8B%E7%BB%8D\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e这是一款全平台通用的换源工具/框架，目标支持 Linux, Windows (MSYS2, Cygwin), macOS, BSD 等尽可能多的操作系统环境，龙芯、飞腾、RISC-V 等尽可能多的 CPU。\u003c/p\u003e","title":"全平台命令行换源工具 chsrc","type":"docs"},{"content":" ONE # 二零二四年八月廿六日，星期六，晴\nTWO # 追-张国荣 Good Night ","date":"2024-09-28","externalUrl":null,"permalink":"/posts/daily/2024-9-28/","section":"帖子","summary":"\u003ch2 class=\"relative group\"\u003eONE \n    \u003cdiv id=\"one\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#one\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cdiv style=\"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年八月廿六日，星期六，晴\u003c/p\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eTWO \n    \u003cdiv id=\"two\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#two\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003ccenter\u003e\n\u003ctext\u003e追-张国荣\u003c/text\u003e\n\u003ciframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/HcSE3cQH-Ic?si=Z0zeizBbsqmpJ8u7\u0026amp;controls=0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen\u003e\u003c/iframe\u003e\n\u003c/center\u003e\n\u003chr\u003e\n\u003cdiv style=\"text-align: center;\"\u003e\n    \u003ch2\u003eGood Night\u003c/h2\u003e\n\u003c/div\u003e","title":"2024 09 28","type":"posts"},{"content":" 二零二四年八月廿五日，星期五，晴\n世界赠予我白纸一张，当然要在人生最好的年华里留下一些痕迹。\n本个人博客基于 Github+Hugo+Blowfish 搭建\n希望在这里记录一些学习与生活点滴\n","date":"2024-09-27","externalUrl":null,"permalink":"/posts/daily/2024-9-27/","section":"帖子","summary":"\u003cdiv style=\"text-align: center;\"\u003e\n    \u003cp\u003e二零二四年八月廿五日，星期五，晴\u003c/p\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cp\u003e世界赠予我白纸一张，当然要在人生最好的年华里留下一些痕迹。\u003c/p\u003e\n\u003cp\u003e本个人博客基于 Github+Hugo+Blowfish 搭建\u003c/p\u003e\n\u003cp\u003e希望在这里记录一些学习与生活点滴\u003c/p\u003e","title":"2024 09 27","type":"posts"},{"content":"","date":"2020-08-14","externalUrl":null,"permalink":"/tags/%E7%A4%BA%E4%BE%8B/","section":"Tags","summary":"","title":"示例","type":"tags"},{"content":" Hi! I am a junior student at Tongji University \\\\ majoring in Computer Science. ","date":"2020-08-14","externalUrl":null,"permalink":"/users/","section":"用户列表","summary":"\u003ccenter\u003e\nHi! I am a junior student at Tongji University \\\\\nmajoring in Computer Science.\n\u003c/center\u003e","title":"用户列表","type":"users"},{"content":"","date":"2020-08-14","externalUrl":null,"permalink":"/tags/%E5%8F%8B%E9%93%BE/","section":"Tags","summary":"","title":"友链","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"I am a junior undergraduate student majoring in Computer Science and Technology at Tongji University.\n","externalUrl":null,"permalink":"/authors/hyoungyan/","section":"Authors","summary":"\u003cp\u003eI am a junior undergraduate student majoring in Computer Science and Technology at Tongji University.\u003c/p\u003e","title":"Hyoung Yan","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"这是高级标记。类似其他 Blowfish 中的其他列表页面，你可以在分类列表页添加自定义内容，这部分内容会显示在顶部。:rocket:\n你也可以用这些内容来定义 Hugo 的元数据，比如标题和描述。这些内容可以被用来增强 SEO 或其他目的。\n","externalUrl":null,"permalink":"/tags/advanced/","section":"Tags","summary":"\u003cp\u003e这是高级标记。类似其他 Blowfish 中的其他列表页面，你可以在分类列表页添加自定义内容，这部分内容会显示在顶部。:rocket:\u003c/p\u003e\n\u003cp\u003e你也可以用这些内容来定义 Hugo 的元数据，比如标题和描述。这些内容可以被用来增强 SEO 或其他目的。\u003c/p\u003e","title":"高级","type":"tags"},{"content":"记录日常阅读、观影、音乐\n","externalUrl":null,"permalink":"/media/","section":".","summary":"\u003cp\u003e记录日常阅读、观影、音乐\u003c/p\u003e","title":"书影音记录","type":"page"},{"content":"在你的文章中添加不同作者的简单示例。\n","externalUrl":null,"permalink":"/medias/","section":"影音","summary":"\u003cp\u003e在你的文章中添加不同作者的简单示例。\u003c/p\u003e","title":"影音","type":"medias"}]